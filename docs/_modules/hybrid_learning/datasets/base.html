

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hybrid_learning.datasets.base &mdash; hybrid_learning  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/autoclasstoc.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> hybrid_learning
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Content</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apiref/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">How to contribute</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">hybrid_learning</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>hybrid_learning.datasets.base</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for hybrid_learning.datasets.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Basic dataset model.</span>

<span class="sd">The abstract BaseDataset handle provides a Sequence, which yields a</span>
<span class="sd">:py:class:`torch.Tensor` tuple of ``(input image, ground truth)`` upon a call to</span>
<span class="sd">__getitem__.</span>
<span class="sd">The transformations from image to tensor data can be changed.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#  Copyright (c) 2020 Continental Automotive GmbH</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> \
    <span class="n">Any</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">ItemsView</span><span class="p">,</span> <span class="n">KeysView</span>

<span class="kn">import</span> <span class="nn">PIL.Image</span>
<span class="kn">import</span> <span class="nn">PIL.ImageEnhance</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">Subset</span>


<div class="viewcode-block" id="DatasetSplit"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DatasetSplit.html#hybrid_learning.datasets.base.DatasetSplit">[docs]</a><span class="k">class</span> <span class="nc">DatasetSplit</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Types of dataset splits.&quot;&quot;&quot;</span>
    <span class="n">VAL</span> <span class="o">=</span> <span class="s2">&quot;val&quot;</span>
    <span class="sd">&quot;&quot;&quot;The validation set for quality checks/early stopping during training.&quot;&quot;&quot;</span>
    <span class="n">TRAIN</span> <span class="o">=</span> <span class="s2">&quot;train&quot;</span>
    <span class="sd">&quot;&quot;&quot;The training set (not for testing or validation).&quot;&quot;&quot;</span>
    <span class="n">TEST</span> <span class="o">=</span> <span class="s2">&quot;test&quot;</span>
    <span class="sd">&quot;&quot;&quot;The test set for testing after finished training.&quot;&quot;&quot;</span>
    <span class="n">TRAIN_VAL</span> <span class="o">=</span> <span class="s2">&quot;train_val&quot;</span>
    <span class="sd">&quot;&quot;&quot;The combined training and validation set.&quot;&quot;&quot;</span>
    <span class="n">ALL</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
    <span class="sd">&quot;&quot;&quot;Combination of all training, validation, and test set.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Nice representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<span class="k">class</span> <span class="nc">_IncompleteDataTriple</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Intermediate storage for data triplets accepting ``None`` entries.&quot;&quot;&quot;</span>
    <span class="n">train</span><span class="p">:</span> <span class="n">Dataset</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Dataset</span>
    <span class="n">test</span><span class="p">:</span> <span class="n">Dataset</span>
    <span class="n">train_val</span><span class="p">:</span> <span class="n">Dataset</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Dataset</span>


<div class="viewcode-block" id="DataTriple"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple">[docs]</a><span class="k">class</span> <span class="nc">DataTriple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Tuple of train/test/validation datasets (w/ automatic splitting if</span>
<span class="sd">    necessary).</span>
<span class="sd">    The splitting is conducted on init.</span>
<span class="sd">    This data structure is considered immutable.</span>
<span class="sd">    So, in order to re-do the splitting, create a new instance with the old</span>
<span class="sd">    specification.</span>

<span class="sd">    To access the held splits either use</span>

<span class="sd">    - the corresponding attributes,</span>
<span class="sd">    - the dict-like getter functionality, or</span>
<span class="sd">    - the dictionary representation of the tuple via :py:meth:`as_dict`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">DEFAULT_VAL_SPLIT</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="sd">&quot;&quot;&quot;Default validation split proportion.</span>
<span class="sd">    This is the proportion of :py:attr:`val` in :py:attr:`train_val`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Training data set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">val</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validation data set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">val_split</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Value of</span>
<span class="sd">        :math:`\frac{len(val)} {len(val) + len(train)}`</span>
<span class="sd">        if none of the datasets is ``None`` or empty.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">train</span> <span class="ow">is</span> <span class="kc">None</span> \
                <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Testing dataset split.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Value of</span>
<span class="sd">        :math:`\frac{len(test)} {len(test) + len(train\_val)}`</span>
<span class="sd">        if none of the datasets is ``None`` or empty.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">test</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_val</span> <span class="ow">is</span> <span class="kc">None</span> \
                <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_val</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">train_val</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combined dataset of training and validation data.</span>

<span class="sd">        It is a concatenation of :py:attr:`train` and :py:attr:`val`</span>
<span class="sd">        or a permutation thereof.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Concatenation of all data (train, val, test) stored in this tuple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

<div class="viewcode-block" id="DataTriple.__init__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">train</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">val</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">test</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">train_val</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">validator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dataset</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">split_kwargs</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Init.</span>

<span class="sd">        Exactly one combination of the following must be given:</span>

<span class="sd">        - ``train``, ``test``, ``val``</span>
<span class="sd">        - ``train_val``, ``test``</span>
<span class="sd">        - ``data``</span>

<span class="sd">        :param test: test dataset</span>
<span class="sd">        :param val: validation dataset</span>
<span class="sd">        :param train: training dataset</span>
<span class="sd">        :param train_val: dataset to split into training and validation dataset</span>
<span class="sd">        :param data: dataset to split into training, validation, and test data</span>
<span class="sd">        :param validator: callable that raises if given dataset is</span>
<span class="sd">            invalid with informative error messages including the given</span>
<span class="sd">            context string;</span>
<span class="sd">            defaults to identity</span>
<span class="sd">        :param split_kwargs: arguments to :py:meth:`split_train_val` and</span>
<span class="sd">            :py:meth:`split_trainval_test` if not all splits are explicitly</span>
<span class="sd">            given; see there for defaults</span>
<span class="sd">        :raises: :py:exc:`ValueError` if the data specification is</span>
<span class="sd">            insufficient or ambiguous,</span>
<span class="sd">            or if the datasets do not pass the validity check</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">triplet</span><span class="p">:</span> <span class="n">_IncompleteDataTriple</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_complete_init_input</span><span class="p">(</span>
                <span class="n">train</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">train_val</span><span class="o">=</span><span class="n">train_val</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">validator</span><span class="o">=</span><span class="n">validator</span><span class="p">,</span> <span class="o">**</span><span class="n">split_kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="n">triplet</span><span class="o">.</span><span class="n">data</span>
        <span class="sd">&quot;&quot;&quot;Internal storage of :py:attr:`data`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="n">triplet</span><span class="o">.</span><span class="n">train</span>
        <span class="sd">&quot;&quot;&quot;Internal storage of :py:attr:`train`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_val</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="n">triplet</span><span class="o">.</span><span class="n">val</span>
        <span class="sd">&quot;&quot;&quot;Internal storage of :py:attr:`val`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_val</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="n">triplet</span><span class="o">.</span><span class="n">train_val</span>
        <span class="sd">&quot;&quot;&quot;Internal storage of :py:attr:`train_val`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_test</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="n">triplet</span><span class="o">.</span><span class="n">test</span>
        <span class="sd">&quot;&quot;&quot;Internal storage of :py:attr:`test`.&quot;&quot;&quot;</span></div>

    <span class="k">def</span> <span class="nf">_complete_init_input</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">train</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">test</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">train_val</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">validator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dataset</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">split_kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IncompleteDataTriple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validate and complete the input arguments to ``__init__`` by</span>
<span class="sd">        splitting or concatenation.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_init_input</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="n">train</span><span class="p">,</span>
                                  <span class="n">train_val</span><span class="o">=</span><span class="n">train_val</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
                                  <span class="n">validator</span><span class="o">=</span><span class="n">validator</span><span class="p">)</span>

        <span class="c1"># region Complete datasets arguments by splitting</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">train_val</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_trainval_test</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">split_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">train_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">train</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_train_val</span><span class="p">(</span><span class="n">train_val</span><span class="p">,</span> <span class="o">**</span><span class="n">split_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">train_val</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ConcatDataset</span><span class="p">([</span><span class="n">train</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ConcatDataset</span><span class="p">([</span><span class="n">train_val</span><span class="p">,</span> <span class="n">test</span><span class="p">])</span>
        <span class="c1"># endregion</span>

        <span class="k">return</span> <span class="n">_IncompleteDataTriple</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
                                     <span class="n">test</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">train_val</span><span class="o">=</span><span class="n">train_val</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_init_input</span><span class="p">(</span><span class="o">*</span><span class="p">,</span>
                             <span class="n">data</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">test</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">train</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">train_val</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">val</span><span class="p">:</span> <span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">validator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dataset</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                                                 <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Parse the given argument combination to a data tuple for</span>
<span class="sd">        :py:meth`_tuple_to_datasets` data preparation.</span>
<span class="sd">        For details on the arguments see ``__init__``.</span>

<span class="sd">        :raises: :py:exc:`ValueError` if the specification is ambiguous or</span>
<span class="sd">            insufficient; errors according to the check in ``validator``</span>
<span class="sd">            for all given datasets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># region Validity of given datasets</span>
        <span class="n">validator</span> <span class="o">=</span> <span class="n">validator</span> \
            <span class="k">if</span> <span class="n">validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">validator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span> <span class="k">for</span> <span class="n">desc</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span>
            <span class="p">{</span><span class="s1">&#39;train&#39;</span><span class="p">:</span> <span class="n">train</span><span class="p">,</span> <span class="s1">&#39;val&#39;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="n">test</span><span class="p">,</span>
             <span class="s1">&#39;train_val&#39;</span><span class="p">:</span> <span class="n">train_val</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="c1"># endregion</span>

        <span class="c1"># region ambiguity or incompleteness of given dataset tuple</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="n">train</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">test</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ambiguous spec: data was given but also a &quot;</span>
                                 <span class="s2">&quot;combination of other dataset specifiers.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data too small for splitting (len </span><span class="si">{}</span><span class="s2">)&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">train_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="n">train</span><span class="p">,</span> <span class="n">val</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ambiguous spec: train_val was given but also &quot;</span>
                                 <span class="s2">&quot;train or val data was specified.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Insufficient spec: test not specified &quot;</span>
                                 <span class="s2">&quot;(test, data, data_tuple were all None).&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;train_val too small for splitting (len </span><span class="si">{}</span><span class="s2">)&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_val</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">validator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span> <span class="k">for</span> <span class="n">desc</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span>
                 <span class="p">{</span><span class="s1">&#39;train&#39;</span><span class="p">:</span> <span class="n">train</span><span class="p">,</span> <span class="s1">&#39;val&#39;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="n">test</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Insufficient spec: all of the following combis &quot;</span>
                             <span class="s2">&quot;contained None values: data_tuple, data, &quot;</span>
                             <span class="s2">&quot;(train_val, test), (train, test, val)&quot;</span><span class="p">)</span>
        <span class="c1"># endregion</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_randomly_split_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
                                <span class="n">split1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">len1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Subset</span><span class="p">,</span> <span class="n">Subset</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Randomly split the given dataset exhaustively into two subsets with</span>
<span class="sd">        specified lengths. Length of the first split will be the floor of</span>
<span class="sd">        :math:`split_1 \cdot len(dataset)`, but at minimum 1.</span>

<span class="sd">        :param dataset: data to split</span>
<span class="sd">        :param split1: proportion of the data samples in first split within</span>
<span class="sd">            dataset;</span>
<span class="sd">            either ``split1`` or ``len1`` must be given; overridden by ``len1``</span>
<span class="sd">        :param len1: length of the desired second split;</span>
<span class="sd">            either ``split1`` or ``len1`` must be given; overrides by ``split1``</span>
<span class="sd">        :return: tuple of two random and exhaustive splits of dataset with</span>
<span class="sd">            according lengths</span>
<span class="sd">        :raises: :py:exc:`ValueError` if the dataset len is &lt; 2 or the ``len1``</span>
<span class="sd">            is not in the necessary range;</span>
<span class="sd">            :py:exc:`AssertionError` if the splitting fails.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Value check:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dataset to split must have len &gt; 1, but was </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">len1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">len1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;Given length of second split </span><span class="si">{}</span><span class="s2"> is not in &quot;</span>
                              <span class="s2">&quot;required range [1, </span><span class="si">{}</span><span class="s2">-1]&quot;</span><span class="p">)</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">len1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)))</span>

        <span class="c1"># Dataset lengths according to val_split:</span>
        <span class="n">len1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">len1</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">split1</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)))</span>
        <span class="n">len2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">-</span> <span class="n">len1</span>

        <span class="c1"># Dataset splitting with success check:</span>
        <span class="n">data_split1</span><span class="p">,</span> <span class="n">data_split2</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">random_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">lengths</span><span class="o">=</span><span class="p">[</span><span class="n">len1</span><span class="p">,</span> <span class="n">len2</span><span class="p">],</span>
                                          <span class="n">generator</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split1</span><span class="p">)</span> <span class="o">==</span> <span class="n">len1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split2</span><span class="p">)</span> <span class="o">==</span> <span class="n">len2</span><span class="p">,</span> \
            <span class="p">((</span><span class="s2">&quot;Dataset splitting failed: expected lengths (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">), &quot;</span>
              <span class="s2">&quot;but got (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">len1</span><span class="p">,</span> <span class="n">len2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split1</span><span class="p">),</span>
                                         <span class="nb">len</span><span class="p">(</span><span class="n">data_split2</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">data_split1</span><span class="p">,</span> <span class="n">data_split2</span>

<div class="viewcode-block" id="DataTriple.split_dataset"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.split_dataset">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">split_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span>
                      <span class="n">indices1</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">indices2</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">len1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">split1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Subset</span><span class="p">,</span> <span class="n">Subset</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Split dataset exhaustively into two subsets, either randomly or</span>
<span class="sd">        according to indices.</span>
<span class="sd">        Yields the resulting splits without changing dataset.</span>
<span class="sd">        For random splitting, the length ``len1`` or split proportion</span>
<span class="sd">        ``split1`` of the first split are used.</span>
<span class="sd">        For splitting by indices, the indices are validated</span>
<span class="sd">        (may take some time ...).</span>

<span class="sd">        Parameter constraints:</span>

<span class="sd">        - At least one of the optional splitting specifiers must be given.</span>
<span class="sd">        - Only true splits of dataset are allowed, i.e. indices if given must</span>
<span class="sd">          not occur twice!</span>
<span class="sd">        - Precedence of given specifiers is as follows (strongest to weakest):</span>

<span class="sd">          - indices</span>
<span class="sd">          - len</span>
<span class="sd">          - split</span>

<span class="sd">        :param dataset: the dataset to split</span>
<span class="sd">        :meta public:</span>
<span class="sd">        :param indices1: Optional indices of the first data split;</span>
<span class="sd">            must be disjoint to ``indices2`` and contain no duplicates;</span>
<span class="sd">            defaults to a random set of indices or those not in indices2 if</span>
<span class="sd">            that is given</span>
<span class="sd">        :param indices2: see ``indices1``</span>
<span class="sd">        :param len1: length of the desired first data split</span>
<span class="sd">        :param split1: proportion of the data samples in second data split of</span>
<span class="sd">            all dataset samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Value checks:</span>
        <span class="c1"># Any splitting specifier given?</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">indices1</span><span class="p">,</span> <span class="n">indices2</span><span class="p">,</span> <span class="n">len1</span><span class="p">,</span> <span class="n">split1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Any of the splitting specifiers must be given, &quot;</span>
                             <span class="s2">&quot;but all were none.&quot;</span><span class="p">)</span>

        <span class="n">total_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="c1"># Are all given indices in range and unique?</span>
        <span class="k">for</span> <span class="n">split</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">indices1</span><span class="p">,</span> <span class="n">indices2</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># elements encountered already</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span> <span class="k">if</span>
                      <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">total_len</span> <span class="ow">or</span>  <span class="c1"># in range?</span>
                      <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">seen</span> <span class="ow">and</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># not duplicate?</span>
                      <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">((</span><span class="s2">&quot;Index </span><span class="si">{}</span><span class="s2"> in split </span><span class="si">{}</span><span class="s2"> out of range of len </span><span class="si">{}</span><span class="s2"> &quot;</span>
                                  <span class="s2">&quot;of dataset&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">total_len</span><span class="p">))</span>

        <span class="c1"># Do the indices not share an index?</span>
        <span class="k">if</span> <span class="n">indices1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">indices2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices1</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;train_indices and val_indices share the &quot;</span>
                                  <span class="s2">&quot;index </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="c1"># Actual splitting:</span>
        <span class="c1"># Either split by given indices ...</span>
        <span class="k">if</span> <span class="n">indices1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">indices2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indices1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indices1</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">indices2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indices2</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices1</span><span class="p">]</span>

            <span class="n">data_split1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Subset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices1</span><span class="p">)</span>
            <span class="n">data_split2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Subset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices2</span><span class="p">)</span>
        <span class="c1"># ... or split randomly</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_split1</span><span class="p">,</span> <span class="n">data_split2</span> <span class="o">=</span> <span class="n">DataTriple</span><span class="o">.</span><span class="n">_randomly_split_dataset</span><span class="p">(</span>
                <span class="n">dataset</span><span class="p">,</span> <span class="n">len1</span><span class="o">=</span><span class="n">len1</span><span class="p">,</span> <span class="n">split1</span><span class="o">=</span><span class="n">split1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_split1</span><span class="p">,</span> <span class="n">data_split2</span></div>

    <span class="c1"># noinspection PyUnusedLocal</span>
<div class="viewcode-block" id="DataTriple.split_train_val"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.split_train_val">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">split_train_val</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                        <span class="n">train_val_data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
                        <span class="n">train_indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">val_indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">val_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">val_split</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">ignored_args</span>  <span class="c1"># pylint: disable=unused-argument</span>
                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Subset</span><span class="p">,</span> <span class="n">Subset</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Split ``train_val_data`` either randomly or according to indices</span>
<span class="sd">        and return splits.</span>
<span class="sd">        This is a wrapper around :py:meth:`split_dataset` with nicer parameter</span>
<span class="sd">        naming, order correction, and defaults. The same parameter constraints</span>
<span class="sd">        apply.</span>

<span class="sd">        :param train_val_data: the dataset to split</span>
<span class="sd">        :param train_indices: Optional indices of the training part of</span>
<span class="sd">            the data set</span>
<span class="sd">        :param val_indices: Optional indices of the validation data set</span>
<span class="sd">        :param val_len: length of the desired validation set split</span>
<span class="sd">        :param val_split: proportion of validation data samples in the total</span>
<span class="sd">            dataset;</span>
<span class="sd">            defaults to :py:attr:`val_split`</span>
<span class="sd">        :return: tuple of splits (``train``, ``val``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val_split</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">val_split</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="n">DEFAULT_VAL_SPLIT</span>
        <span class="n">val_data</span><span class="p">,</span> <span class="n">train_data</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">split_dataset</span><span class="p">(</span><span class="n">train_val_data</span><span class="p">,</span>
                                                 <span class="n">indices1</span><span class="o">=</span><span class="n">val_indices</span><span class="p">,</span>
                                                 <span class="n">indices2</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
                                                 <span class="n">len1</span><span class="o">=</span><span class="n">val_len</span><span class="p">,</span>
                                                 <span class="n">split1</span><span class="o">=</span><span class="n">val_split</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">val_data</span></div>

    <span class="c1"># noinspection PyUnusedLocal</span>
<div class="viewcode-block" id="DataTriple.split_trainval_test"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.split_trainval_test">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">split_trainval_test</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                            <span class="n">data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
                            <span class="n">train_val_indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">test_indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">test_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">test_split</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">ignored_args</span>  <span class="c1"># pylint: disable=unused-argument</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Subset</span><span class="p">,</span> <span class="n">Subset</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Split ``data`` either randomly or according to indices</span>
<span class="sd">        and return splits.</span>
<span class="sd">        This is a wrapper around :py:meth:`split_dataset` with nicer parameter</span>
<span class="sd">        naming, order correction, and defaults. The same parameter constraints</span>
<span class="sd">        apply.</span>

<span class="sd">        :param data: the dataset to split</span>
<span class="sd">        :param train_val_indices: Optional indices of the training part of</span>
<span class="sd">            the data set</span>
<span class="sd">        :param test_indices: Optional indices of the validation data set</span>
<span class="sd">        :param test_len: length of the desired validation set split</span>
<span class="sd">        :param test_split: proportion of validation data samples in the total</span>
<span class="sd">            dataset;</span>
<span class="sd">            defaults to :py:attr:`test_split`</span>
<span class="sd">        :return: tuple of splits (``train_val``, ``test``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">test_split</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_split</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="n">DEFAULT_VAL_SPLIT</span>
        <span class="n">val_data</span><span class="p">,</span> <span class="n">train_data</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">split_dataset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                                 <span class="n">indices1</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
                                                 <span class="n">indices2</span><span class="o">=</span><span class="n">train_val_indices</span><span class="p">,</span>
                                                 <span class="n">len1</span><span class="o">=</span><span class="n">test_len</span><span class="p">,</span>
                                                 <span class="n">split1</span><span class="o">=</span><span class="n">test_split</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">val_data</span></div>

<div class="viewcode-block" id="DataTriple.validate_by"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.validate_by">[docs]</a>    <span class="k">def</span> <span class="nf">validate_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dataset</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validate all data splits using validator, which raises in case of</span>
<span class="sd">        invalid format.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">desc</span><span class="p">,</span> <span class="n">data_split</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">validator</span><span class="p">(</span><span class="n">data_split</span><span class="p">,</span> <span class="n">desc</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Provide a string with some statistics on the held datasets.&quot;&quot;&quot;</span>
        <span class="c1"># Some size information</span>
        <span class="n">info</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[{</span><span class="s2">&quot;split&quot;</span><span class="p">:</span> <span class="n">split</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
              <span class="s2">&quot;len&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span>
              <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">}</span>
             <span class="k">for</span> <span class="n">split</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;split&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">info</span>

<div class="viewcode-block" id="DataTriple.__repr__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;String representation of the held dataset splits.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;    train=</span><span class="si">{train}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;    val=</span><span class="si">{val}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;    test=</span><span class="si">{test}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                            <span class="n">train</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">),</span>
                            <span class="n">val</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">),</span>
                            <span class="n">test</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">))</span></div>

<div class="viewcode-block" id="DataTriple.__eq__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check that all data sub-sets are the same objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">train</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">test</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_val</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">train_val</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataTriple.as_dict"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DatasetSplit</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Dict of the splits (train, val, test) held in this triple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TRAIN</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">,</span>
                <span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TEST</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">,</span>
                <span class="n">DatasetSplit</span><span class="o">.</span><span class="n">VAL</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">}</span></div>

<div class="viewcode-block" id="DataTriple.items"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ItemsView</span><span class="p">[</span><span class="n">DatasetSplit</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Dataset split items.</span>
<span class="sd">        Items of :py:meth:`as_dict` output.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span></div>

<div class="viewcode-block" id="DataTriple.keys"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">KeysView</span><span class="p">[</span><span class="n">DatasetSplit</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Dataset split keys.</span>
<span class="sd">         Keys of :py:meth:`as_dict` output.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="DataTriple.__getitem__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">DatasetSplit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get dataset split by split identifier.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="DataTriple.from_dict"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.DataTriple.html#hybrid_learning.datasets.base.DataTriple.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">splits</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DatasetSplit</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataTriple&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create :py:class:`DataTriple` from a dict of datasets indexed by</span>
<span class="sd">        their split.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">train</span><span class="o">=</span><span class="n">splits</span><span class="p">[</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TRAIN</span><span class="p">],</span>
                   <span class="n">test</span><span class="o">=</span><span class="n">splits</span><span class="p">[</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TEST</span><span class="p">],</span>
                   <span class="n">val</span><span class="o">=</span><span class="n">splits</span><span class="p">[</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">VAL</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="BaseDataset"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.BaseDataset.html#hybrid_learning.datasets.base.BaseDataset">[docs]</a><span class="k">class</span> <span class="nc">BaseDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for tuple datasets with storage location.</span>

<span class="sd">    Derived datasets should yield tuples of ``(input, target)``.</span>
<span class="sd">    The transformation :py:attr:`transforms` is applied to data</span>
<span class="sd">    tuples before return from :py:meth:`__getitem__` can be controlled.</span>
<span class="sd">    The default for :py:attr:`transforms` is given by</span>
<span class="sd">    The default for :py:attr:`transforms` is given by</span>
<span class="sd">    :py:meth:`_default_transforms`. Override in sub-classes if necessary.</span>
<span class="sd">    The default combination of collected dataset tuples and</span>
<span class="sd">    :py:meth:`_default_transforms` should yield a tuple</span>
<span class="sd">    of :py:class:`torch.Tensor` or dicts thereof.</span>

<span class="sd">    The :py:attr:`hybrid_learning.datasets.base.BaseDataset.dataset_root` is</span>
<span class="sd">    assumed to provide information about the storage location.</span>
<span class="sd">    Best, all components (input data, annotations, etc.)</span>
<span class="sd">    should be stored relative to this root location.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseDataset.__init__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.BaseDataset.html#hybrid_learning.datasets.base.BaseDataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split</span><span class="p">:</span> <span class="n">DatasetSplit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dataset_root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transforms</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Init.</span>

<span class="sd">        :param split: The split of the dataset</span>
<span class="sd">            (e.g. :py:attr:`DatasetSplit.TRAIN`,</span>
<span class="sd">            :py:attr:`DatasetSplit.VAL`, :py:attr:`DatasetSplit.TEST`).</span>
<span class="sd">        :param dataset_root: The location where to store the dataset.</span>
<span class="sd">        :param transforms: The transformations to be applied to the data when</span>
<span class="sd">            loaded; defaults to :py:meth:`_default_transforms`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DatasetSplit</span><span class="p">]</span> <span class="o">=</span> <span class="n">split</span>
        <span class="sd">&quot;&quot;&quot;Optional specification what use-case this dataset is meant to</span>
<span class="sd">        represent, e.g. training, validation, or testing.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">dataset_root</span>
        <span class="sd">&quot;&quot;&quot;Assuming the dataset is saved in some storage location, a root</span>
<span class="sd">        from which to navigate to the dataset information.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">transforms</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_transforms</span>
        <span class="sd">&quot;&quot;&quot;Transformation function applied to each item tuple before return.</span>
<span class="sd">        Applied in :py:meth:`__getitem__`.</span>
<span class="sd">        Default transformations are sub-class-specific.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dataset_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dataset_root</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s2">&quot;Dataset root </span><span class="si">{}</span><span class="s2"> does not exist&quot;</span>
                                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dataset_root</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dataset_root</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotADirectoryError</span><span class="p">(</span><span class="s2">&quot;Dataset root is not a directory: </span><span class="si">{}</span><span class="s2">&quot;</span>
                                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dataset_root</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseDataset.__len__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.BaseDataset.html#hybrid_learning.datasets.base.BaseDataset.__len__">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of data points in the dataset; to be implemented in</span>
<span class="sd">        subclasses.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseDataset.getitem"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.BaseDataset.html#hybrid_learning.datasets.base.BaseDataset.getitem">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">],</span>
                           <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">,</span>
                                 <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Get data item tuple from ``idx`` in this dataset.</span>

<span class="sd">        :param idx: index to retrieve data point from</span>
<span class="sd">        :return: tuple ``(input, label)`` with</span>

<span class="sd">            - ``input`` one of: image (as :py:class:`PIL.Image.Image`),</span>
<span class="sd">              Radar/Lidar point cloud</span>
<span class="sd">            - ``label`` one of:</span>

<span class="sd">              - None</span>
<span class="sd">              - class label (as :py:class:`torch.Tensor` or ``bool``),</span>
<span class="sd">              - semantic segmentation map (as :py:class:`PIL.Image.Image` or</span>
<span class="sd">                :py:class:`torch.Tensor` compatible with torchvision</span>
<span class="sd">                transforms),</span>
<span class="sd">              - bounding box</span>
<span class="sd">              - string-indexed dict of combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseDataset.__getitem__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.BaseDataset.html#hybrid_learning.datasets.base.BaseDataset.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get item from ``idx`` in dataset with transformations applied.</span>
<span class="sd">        Transformations must be stored as single tuple transformation in</span>
<span class="sd">        :py:attr:`transforms`.</span>

<span class="sd">        :return: tuple output of :py:meth:`getitem` transformed by</span>
<span class="sd">            :py:attr:`transforms`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inp</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">settings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Settings of the instance.</span>
<span class="sd">         :py:attr:`transforms` info is skipped if set to default.&quot;&quot;&quot;</span>
        <span class="n">trafo_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;transforms&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">}</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_transforms</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="n">split_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;split&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">}</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dataset_root</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_root</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">split_info</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">trafo_info</span>
                    <span class="p">)</span>

<div class="viewcode-block" id="BaseDataset.__repr__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.BaseDataset.html#hybrid_learning.datasets.base.BaseDataset.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Nice printing function.&quot;&quot;&quot;</span>
        <span class="n">other_info</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                                     <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{cls}</span><span class="s1">(len=</span><span class="si">{len}</span><span class="s1">, </span><span class="si">{other}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                  <span class="nb">len</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(),</span>
                                                  <span class="n">other</span><span class="o">=</span><span class="n">other_info</span><span class="p">)</span></div>

    <span class="c1"># The default function does not use self, but overriding functions may</span>
    <span class="c1"># pylint: disable=no-self-use</span>
<div class="viewcode-block" id="BaseDataset._default_transforms"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.BaseDataset.html#hybrid_learning.datasets.base.BaseDataset._default_transforms">[docs]</a>    <span class="k">def</span> <span class="nf">_default_transforms</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">inp</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
            <span class="n">ground_truth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Default transformation method (identity).</span>

<span class="sd">        :meta public:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ground_truth</span></div></div>
    <span class="c1"># pylint: enable=no-self-use</span>


<span class="c1"># DATASET INDEX MANIPULATION</span>
<span class="c1"># --------------------------</span>
<div class="viewcode-block" id="cross_validation_splits"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.datasets.base.cross_validation_splits.html#hybrid_learning.datasets.base.cross_validation_splits">[docs]</a><span class="k">def</span> <span class="nf">cross_validation_splits</span><span class="p">(</span><span class="n">train_val_data</span><span class="p">,</span> <span class="n">num_splits</span><span class="p">:</span> <span class="nb">int</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Subset</span><span class="p">,</span> <span class="n">Subset</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Split dataset it into ``num_splits`` and collect tuples of</span>
<span class="sd">    ``(rest, split)``.</span>
<span class="sd">    This is useful for creating splits for cross-validation, where ``rest``</span>
<span class="sd">    would be the training data, and ``split`` would be the validation data</span>
<span class="sd">    split.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_splits</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_splits must be integer &gt; 1 but was </span><span class="si">{}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_splits</span><span class="p">))</span>

    <span class="c1"># lengths of the validation splits:</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">train_val_data</span><span class="p">)</span> <span class="o">//</span> <span class="n">num_splits</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_splits</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_val_data</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_splits</span><span class="p">):</span>
        <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># list of index lists for the validation splits</span>
    <span class="c1"># noinspection PyTypeChecker</span>
    <span class="n">val_split_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span>
                      <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">random_split</span><span class="p">(</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_val_data</span><span class="p">)),</span> <span class="n">lengths</span><span class="p">,</span>
                          <span class="n">generator</span><span class="o">=</span><span class="kc">None</span><span class="p">)]</span>

    <span class="c1"># Collect the train and validation subset for each split</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">val_id</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val_split_idxs</span><span class="p">):</span>
        <span class="n">train_data</span> <span class="o">=</span> <span class="n">Subset</span><span class="p">(</span><span class="n">train_val_data</span><span class="p">,</span>
                            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">v_id</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val_split_idxs</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span> <span class="k">if</span> <span class="n">v_id</span> <span class="o">!=</span> <span class="n">val_id</span><span class="p">])</span>
        <span class="n">val_data</span> <span class="o">=</span> <span class="n">Subset</span><span class="p">(</span><span class="n">train_val_data</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">train_data</span><span class="p">,</span> <span class="n">val_data</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">splits</span></div>

<span class="c1"># HASHING METHODS</span>
<span class="c1"># ---------------</span>
<span class="c1"># import hashlib</span>
<span class="c1"># def model_parameter_hash(model: torch.nn.Module,</span>
<span class="c1">#                          hash_len: Optional[int] = None) -&gt; str:</span>
<span class="c1">#     &quot;&quot;&quot;Produce a truncated hex hash from the state of a pytorch model</span>
<span class="c1">#     (and only from that).</span>
<span class="c1">#     Guarantee: Two models whose parameters origin from the same file</span>
<span class="c1">#     yield the same hash.</span>
<span class="c1">#</span>
<span class="c1">#     .. note::</span>
<span class="c1">#       This can take extremely long (e.g. 60s for Mask R-CNN).</span>
<span class="c1">#</span>
<span class="c1">#     The hard part is that the hash should really only depend on the model</span>
<span class="c1">#     parameter data (and possibly architecture), so</span>
<span class="c1">#</span>
<span class="c1">#     - no standard hash() can be used: this is session dependent</span>
<span class="c1">#     - no hash of pickled models can be used: these save positions in memory</span>
<span class="c1">#       which change;</span>
<span class="c1">#       Instead, the parameters are parsed to a string representation to be</span>
<span class="c1">#       then hashed.</span>
<span class="c1">#</span>
<span class="c1">#     :param hash_len: Length to which to truncate the hash; no truncation if</span>
<span class="c1">#         ``None``</span>
<span class="c1">#     :param model: torch model to hash the state of.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     if hash_len is not None and hash_len &lt;= 0:</span>
<span class="c1">#         raise ValueError(&quot;Hash length must &gt;0 but was {}&quot;.format(hash_len))</span>
<span class="c1">#</span>
<span class="c1">#     state_dict: Dict[str, torch.Tensor] = model.state_dict()</span>
<span class="c1">#</span>
<span class="c1">#     # Apply the magic:</span>
<span class="c1">#     # Represent the complete state_dict ({str: tensors}) as encoded</span>
<span class="c1">#     # string to make it hashable.</span>
<span class="c1">#     # Mind the sorting to make this deterministic.</span>
<span class="c1">#     hashable_state_dict: bytes = &#39;\n&#39;.join((</span>
<span class="c1">#         &quot;{!s}\t{!s}&quot;.format(k, v.tolist())</span>
<span class="c1">#         for k, v in sorted(state_dict.items())</span>
<span class="c1">#     )).encode()</span>
<span class="c1">#</span>
<span class="c1">#     # Now create the hex hash.</span>
<span class="c1">#     state_dict_hash: int = hashlib.md5(hashable_state_dict).hexdigest()</span>
<span class="c1">#</span>
<span class="c1">#     # Truncate if necessary</span>
<span class="c1">#     format_str = &quot;0x{!s&quot; + (&quot;}&quot; if hash_len is None else</span>
<span class="c1">#                             &quot;:0&lt;&quot; + str(hash_len) + &quot;.&quot; + str(hash_len) + &quot;}&quot;)</span>
<span class="c1">#     return format_str.format(state_dict_hash)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Continental Automotive GmbH

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>