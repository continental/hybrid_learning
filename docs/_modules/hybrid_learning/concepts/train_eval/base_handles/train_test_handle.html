<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hybrid_learning.concepts.train_eval.base_handles.train_test_handle &mdash; hybrid_learning  documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/autoclasstoc.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../../index.html" class="icon icon-home"> hybrid_learning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Content</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../quickstart/index.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../userguide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apiref/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing.html">How to contribute</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">hybrid_learning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
      <li>hybrid_learning.concepts.train_eval.base_handles.train_test_handle</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hybrid_learning.concepts.train_eval.base_handles.train_test_handle</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Abstract handle for standard training and testing of pytorch models.&quot;&quot;&quot;</span>

<span class="c1">#  Copyright (c) 2022 Continental Automotive GmbH</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> \
    <span class="n">List</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span>
<span class="kn">import</span> <span class="nn">torch.utils</span>
<span class="kn">from</span> <span class="nn">torch.optim.optimizer</span> <span class="kn">import</span> <span class="n">Optimizer</span>  <span class="c1"># pylint: disable=no-name-in-module</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Subset</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">hybrid_learning.datasets</span> <span class="kn">import</span> <span class="n">BaseDataset</span><span class="p">,</span> <span class="n">DataTriple</span><span class="p">,</span> <span class="n">DatasetSplit</span>
<span class="kn">from</span> <span class="nn">hybrid_learning.datasets</span> <span class="kn">import</span> <span class="n">cross_validation_splits</span>
<span class="kn">from</span> <span class="nn">hybrid_learning.datasets.transforms</span> <span class="kn">import</span> <span class="n">ReduceTuple</span>
<span class="kn">from</span> <span class="nn">hybrid_learning.datasets.transforms</span> <span class="kn">import</span> <span class="n">TupleTransforms</span>
<span class="kn">from</span> <span class="nn">.early_stopping</span> <span class="kn">import</span> <span class="n">EarlyStoppingHandle</span>
<span class="kn">from</span> <span class="nn">.resettable_optimizer</span> <span class="kn">import</span> <span class="n">ResettableOptimizer</span>
<span class="kn">from</span> <span class="nn">..callbacks</span> <span class="kn">import</span> <span class="n">run_callbacks</span><span class="p">,</span> <span class="n">CallbackEvents</span><span class="p">,</span> <span class="n">_validate_templ</span><span class="p">,</span> <span class="n">LoggingCallback</span><span class="p">,</span> <span class="n">ProgressBarUpdater</span>
<span class="kn">from</span> <span class="nn">..train_eval_funs</span> <span class="kn">import</span> <span class="n">train_one_epoch</span><span class="p">,</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">second_stage_train</span><span class="p">,</span> <span class="n">device_of</span><span class="p">,</span> <span class="n">loader</span>
<span class="kn">from</span> <span class="nn">..kpis</span> <span class="kn">import</span> <span class="n">aggregating_kpis</span>

<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="TrainEvalHandle"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle">[docs]</a><span class="k">class</span> <span class="nc">TrainEvalHandle</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>  <span class="c1"># pylint: disable=too-many-instance-attributes</span>
    <span class="c1"># pylint: disable=line-too-long</span>
    <span class="sd">&quot;&quot;&quot;Handle for training and evaluation of pytorch models.</span>
<span class="sd">    The model base class should be :py:class:`torch.nn.Module`.</span>

<span class="sd">    The main functions are :py:meth:`train` and :py:meth:`evaluate`.</span>
<span class="sd">    Metrics and loss functions must be given on initialization.</span>
<span class="sd">    Training and evaluation results are returned as</span>
<span class="sd">    :py:class:`pandas.DataFrame` resp. :py:class:`pandas.Series` with columns</span>
<span class="sd">    the metric keys (prefixed according to the mode).</span>
<span class="sd">    Modes can be train, test, or validation (see instances of</span>
<span class="sd">    :py:class:`~hybrid_learning.datasets.base.DatasetSplit` enum).</span>
<span class="sd">    The non-prefixed loss key is saved in :py:const:`LOSS_KEY`.</span>

<span class="sd">    For a usage example see</span>
<span class="sd">    :py:class:`~hybrid_learning.concepts.models.concept_models.concept_detection.ConceptDetection2DTrainTestHandle`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: enable=line-too-long</span>
    <span class="n">LOSS_KEY</span> <span class="o">=</span> <span class="s1">&#39;loss&#39;</span>
    <span class="sd">&quot;&quot;&quot;Key for the loss evaluation results.&quot;&quot;&quot;</span>
    <span class="n">NLL_KEY</span> <span class="o">=</span> <span class="s1">&#39;NLL&#39;</span>
    <span class="sd">&quot;&quot;&quot;Key for the proper scoring evaluation function used for second stage</span>
<span class="sd">    training. Typically a negative log-likelihood.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="TrainEvalHandle.prefix_by"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.prefix_by">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">prefix_by</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">DatasetSplit</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prefix ``s`` with the given mode.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span></div>

<div class="viewcode-block" id="TrainEvalHandle.test_"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.test_">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">test_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get name of metric for testing results.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prefix_by</span><span class="p">(</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="TrainEvalHandle.train_"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.train_">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">train_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get name of metric for training results.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prefix_by</span><span class="p">(</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TRAIN</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="TrainEvalHandle.val_"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.val_">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">val_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get name of metric for validation results.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prefix_by</span><span class="p">(</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">VAL</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kpi_fns</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Metric *and* loss functions.</span>
<span class="sd">        Nomenclature: :py:attr:`metric_fns` holds all metrics meant for</span>
<span class="sd">        evaluation, while :py:attr:`kpi_fns` also encompasses the losses.&quot;&quot;&quot;</span>
        <span class="n">losses</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">LOSS_KEY</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span><span class="p">}</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nll_fn</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nll_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">losses</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">NLL_KEY</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nll_fn</span><span class="p">})</span>
        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="n">losses</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">metric_fns</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">settings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The current training settings as dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">batch_size_val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size_val</span><span class="p">,</span>
            <span class="n">batch_size_hessian</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size_hessian</span><span class="p">,</span>
            <span class="n">max_epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">num_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span><span class="p">,</span>
            <span class="n">loss_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span><span class="p">,</span>
            <span class="n">nll_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nll_fn</span><span class="p">,</span>
            <span class="n">metric_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metric_fns</span><span class="p">,</span>
            <span class="n">early_stopping_handle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">early_stopping_handle</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">callbacks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">,</span>
            <span class="n">callback_context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_context</span><span class="p">,</span>
            <span class="n">show_progress_bars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">show_progress_bars</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TrainEvalHandle.__repr__"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                               <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;=&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">)])</span>
                                          <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">items</span><span class="p">()]))</span></div>

    <span class="k">def</span> <span class="nf">_show_progress_bars_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DatasetSplit</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Whether to show the progress for the respective run mode.</span>
<span class="sd">        See :py:attr:`show_progress_bars`.&quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_validated_split</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_progress_bars</span> <span class="o">==</span> <span class="s1">&#39;always&#39;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_progress_bars</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="TrainEvalHandle.__init__"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">:</span> <span class="n">DataTriple</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">batch_size_val</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">batch_size_hessian</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_workers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">loss_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">nll_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">metric_fns</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">aggregating_kpis</span><span class="o">.</span><span class="n">AggregatingKpi</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span>
                     <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">early_stopping_handle</span><span class="p">:</span> <span class="n">EarlyStoppingHandle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">optimizer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">model_output_transform</span><span class="p">:</span> <span class="n">TupleTransforms</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">metric_input_transform</span><span class="p">:</span> <span class="n">TupleTransforms</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">callbacks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">CallbackEvents</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">callback_context</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">show_progress_bars</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="p">):</span>  <span class="c1"># pylint: disable=too-many-arguments</span>
        <span class="c1"># pylint: disable=line-too-long</span>
        <span class="sd">&quot;&quot;&quot;Init.</span>

<span class="sd">        :param model: model to train/eval</span>
<span class="sd">        :param device: device on which to load the data and the model parameters</span>
<span class="sd">        :param num_workers: number of workers to use for data loading;</span>
<span class="sd">            see :py:meth:`loader`; single process loading is used if unset or &lt;2</span>
<span class="sd">        :param optimizer: callable that yields a fresh optimizer instance</span>
<span class="sd">            when called on the model&#39;s trainable parameters</span>
<span class="sd">        :param early_stopping_handle: handle for early stopping;</span>
<span class="sd">            defaults to default</span>
<span class="sd">            :py:class:`~hybrid_learning.concepts.train_eval.base_handles.early_stopping.EarlyStoppingHandle`</span>
<span class="sd">            if ``None``; set to ``False`` to disable early stopping;</span>
<span class="sd">        :param loss_fn: differentiable metric function to use as loss</span>
<span class="sd">        :param nll_fn: Negative log likelihood (or other proper scoring</span>
<span class="sd">            function) for use as Laplace approximation</span>
<span class="sd">        :param metric_fns: Dictionary of metric functions, each accepting</span>

<span class="sd">            - the batch model output tensor, and</span>
<span class="sd">            - the batch ground truth tensor</span>

<span class="sd">            and yields the value of the specified metric.</span>
<span class="sd">        :param model_output_transform: transformation applied to</span>
<span class="sd">            the tuples of ``(model output, target)`` before applying loss</span>
<span class="sd">            functions or metric functions;</span>
<span class="sd">            the functions are wrapped correspondingly;</span>
<span class="sd">        :param metric_input_transform: transformation applied to</span>
<span class="sd">            the tuples of ``(model output, target)`` before applying metric</span>
<span class="sd">            functions only (not the loss and scoring functions), after</span>
<span class="sd">            model_output_transform is applied;</span>
<span class="sd">            the functions are wrapped correspondingly;</span>
<span class="sd">            meant as convenient way to modify metrics simultaneously</span>
<span class="sd">        :param callbacks: see :py:attr:`callbacks`</span>
<span class="sd">        :param show_progress_bars: see :py:attr:`show_progress_bars`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: enable=line-too-long</span>

        <span class="c1"># The model to train/eval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span> <span class="o">=</span> <span class="n">model</span>
        <span class="sd">&quot;&quot;&quot;The model to work on.&quot;&quot;&quot;</span>

        <span class="c1"># General args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span> <span class="ow">or</span> <span class="n">device_of</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Device to run training and testing on (this is where the data</span>
<span class="sd">        loaders are put).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="ow">or</span> <span class="mi">8</span>
        <span class="sd">&quot;&quot;&quot;Default training batch size.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size_val</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">batch_size_val</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="sd">&quot;&quot;&quot;Default validation batch size.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size_hessian</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">batch_size_hessian</span> <span class="ow">or</span> <span class="mi">8</span>
        <span class="sd">&quot;&quot;&quot;Default batch size for calculating the hessian.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">max_epochs</span> <span class="ow">or</span> <span class="mi">5</span>
        <span class="sd">&quot;&quot;&quot;Default maximum number of epochs.</span>
<span class="sd">        May be reduced by :py:attr:`early_stopping_handle`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">num_workers</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The default number of workers to use for data loading.</span>
<span class="sd">        See :py:meth:`hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.loader`.</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># pylint: disable=line-too-long</span>
        <span class="n">show_progress_bars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">show_progress_bars</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show_progress_bars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">show_progress_bars</span> \
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">show_progress_bars</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;train&#39;</span>
        <span class="sd">&quot;&quot;&quot;Whether to show progress bars for batch-wise operations.</span>
<span class="sd">        Value must be a comma-separated concatenation of run types</span>
<span class="sd">        (the values of dataset splits) for which to show progress,</span>
<span class="sd">        or ``&#39;always&#39;``.&quot;&quot;&quot;</span>

        <span class="c1"># KPI functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">loss_fn</span>
        <span class="sd">&quot;&quot;&quot;Loss function callable.</span>
<span class="sd">        Defaults to a balanced binary cross-entropy assuming on average 1%</span>
<span class="sd">        positive px per img.</span>
<span class="sd">        Must be wrapped into a tuple to hide the parameters, since these are</span>
<span class="sd">        not to be updated.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nll_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">nll_fn</span> <span class="k">if</span> <span class="n">nll_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span>
        <span class="sd">&quot;&quot;&quot;Proper scoring function callable used as loss in second stage</span>
<span class="sd">        training for Laplace approximation.</span>
<span class="sd">        Usually is chosen as negative log-likelihood, defaults to</span>
<span class="sd">        :py:attr:`loss_fn`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric_fns</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">aggregating_kpis</span><span class="o">.</span><span class="n">AggregatingKpi</span><span class="p">,</span>
                       <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]]</span> \
            <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">metric_fns</span><span class="p">)</span> <span class="k">if</span> <span class="n">metric_fns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of metric functions to apply for evaluation and logging.</span>
<span class="sd">        Each function must have a signature of</span>
<span class="sd">        ``(output, target) -&gt; metric_value``. See also :py:attr:`kpi_fns`.</span>
<span class="sd">        Keys must not contain :py:const:`LOSS_KEY` or :py:const:`NLL_KEY`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model_output_transform</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span> <span class="o">=</span> <span class="n">ReduceTuple</span><span class="p">(</span><span class="n">model_output_transform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nll_fn</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nll_fn</span> <span class="o">=</span> <span class="n">ReduceTuple</span><span class="p">(</span><span class="n">model_output_transform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nll_fn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_output_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">metric_input_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transformer</span> <span class="o">=</span> <span class="n">model_output_transform</span> <span class="o">+</span> <span class="n">metric_input_transform</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric_fns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metric_fns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReduceTuple</span><span class="p">(</span><span class="n">transformer</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">metric_fns</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

        <span class="c1"># Additional handles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">:</span> <span class="n">ResettableOptimizer</span> <span class="o">=</span> \
            <span class="n">optimizer</span> <span class="ow">or</span> <span class="n">ResettableOptimizer</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">,</span>
                                             <span class="n">lr</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                                             <span class="n">weight_decay</span><span class="o">=</span><span class="mf">0.</span>
                                             <span class="c1"># do not add L2 regularization</span>
                                             <span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Optimizer and learning rate scheduler handle.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">early_stopping_handle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EarlyStoppingHandle</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">early_stopping_handle</span>
        <span class="sd">&quot;&quot;&quot;Handle that is stepped during training and indicates need for</span>
<span class="sd">        early stopping.</span>
<span class="sd">        To disable early stopping, set :py:attr:`early_stopping_handle` to</span>
<span class="sd">        ``None`` resp. specify ``early_stopping_handle=False`` in</span>
<span class="sd">        ``__init__`` arguments.&quot;&quot;&quot;</span>

        <span class="c1"># Data loaders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span> <span class="n">DataTriple</span> <span class="o">=</span> <span class="n">data</span>
        <span class="sd">&quot;&quot;&quot;Train, validation, and test data splits to use.</span>
<span class="sd">        Must be converted to data loaders before usage.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">CallbackEvents</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="n">callbacks</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;A dictionary mapping events to a list of callables that are called</span>
<span class="sd">        every time the event occurs with the current state.</span>
<span class="sd">        Some default logging callbacks are defined.</span>

<span class="sd">        For details on available events, see</span>
<span class="sd">        :py:class:`hybrid_learning.concepts.train_eval.callbacks.CallbackEvents`.</span>
<span class="sd">        After the event, all callbacks for this event are called in order</span>
<span class="sd">        with keyword arguments from a</span>
<span class="sd">        :py:attr:`hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.callback_context`.</span>
<span class="sd">        The base context is dependent on the event and includes e.g. the model,</span>
<span class="sd">        and can be extended by specifying the callback context during</span>
<span class="sd">        function call or in the default callback context.</span>
<span class="sd">        Note that side effects on objects in the callback context (e.g. the</span>
<span class="sd">        model) will influence the training.</span>
<span class="sd">        Callback application examples:</span>

<span class="sd">        - Logging</span>
<span class="sd">        - Storing of best n models</span>
<span class="sd">        - Results saving, e.g. to tensorboard or sacred log</span>
<span class="sd">        - Forced weight normalization</span>

<span class="sd">        Callbacks can be</span>
<span class="sd">        :py:meth:`added &lt;hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.add_callbacks&gt;`</span>
<span class="sd">        and</span>
<span class="sd">        :py:meth:`removed &lt;hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.remove_callback&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># always ensure a logger and pbar updater are available:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">LoggingCallback</span><span class="p">)</span> <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_callbacks</span><span class="p">([</span><span class="n">LoggingCallback</span><span class="p">(</span><span class="n">LOGGER</span><span class="p">,</span> <span class="n">log_per_batch</span><span class="o">=</span><span class="mi">10</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_progress_bars</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">ProgressBarUpdater</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_callbacks</span><span class="p">([</span><span class="n">ProgressBarUpdater</span><span class="p">()])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">callback_context</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback_context</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;The default callback context values to use.</span>
<span class="sd">        In any training run where context is used, the context can either be</span>
<span class="sd">        handed over or it defaults to a copy of this dict.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="TrainEvalHandle.add_callbacks"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.add_callbacks">[docs]</a>    <span class="k">def</span> <span class="nf">add_callbacks</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">CallbackEvents</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Append the given callbacks.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">callbacks</span><span class="p">)</span></div>

<div class="viewcode-block" id="TrainEvalHandle.remove_callback"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.remove_callback">[docs]</a>    <span class="k">def</span> <span class="nf">remove_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a single given callback.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">callback</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_to_validated_split</span><span class="p">(</span><span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DatasetSplit</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">DatasetSplit</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Turn a string specifier to a dataset split if necessary.&quot;&quot;&quot;</span>
        <span class="n">translations</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">DatasetSplit</span> <span class="k">if</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">mode</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">mode</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">mode</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">translations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">translations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">translations</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;Ambiguous mode specification </span><span class="si">{}</span><span class="s2">: found splits </span><span class="si">{}</span><span class="s2">&quot;</span>
                                  <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">translations</span><span class="p">))</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">translations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">DatasetSplit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid mode </span><span class="si">{}</span><span class="s2"> given. Accepting </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">mode</span><span class="p">,</span> <span class="p">[</span><span class="o">*</span><span class="n">DatasetSplit</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">DatasetSplit</span><span class="p">]]))</span>
        <span class="k">return</span> <span class="n">mode</span>

<div class="viewcode-block" id="TrainEvalHandle.loader"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.loader">[docs]</a>    <span class="k">def</span> <span class="nf">loader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">BaseDataset</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="o">*</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DatasetSplit</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">num_workers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataLoader</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prepare and return a torch data loader from the dataset</span>
<span class="sd">        according to settings.</span>
<span class="sd">        For details see :py:meth:`~hybrid_learning.concepts.train_eval.train_eval_funs.loader`.</span>

<span class="sd">        :param data: data to obtain loader for; defaults to</span>
<span class="sd">            :py:attr:`data` of respective ``mode``</span>
<span class="sd">        :param mode: which :py:attr:`data` split to use by default;</span>
<span class="sd">            specify as instance of</span>
<span class="sd">            :py:class:`~hybrid_learning.datasets.base.DatasetSplit`</span>
<span class="sd">            or the name of one;</span>
<span class="sd">        :param batch_size: defaults to :py:attr:`batch_size`</span>
<span class="sd">        :param device: defaults to :py:attr:`device`</span>
<span class="sd">        :param num_workers: defaults to :py:attr:`num_workers`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either data or mode must be given.&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_validated_split</span><span class="p">(</span><span class="n">mode</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">loader</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span>
                      <span class="n">batch_size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">batch_size</span><span class="p">),</span>
                      <span class="n">num_workers</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span> <span class="k">if</span> <span class="n">num_workers</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">num_workers</span><span class="p">))</span></div>

<div class="viewcode-block" id="TrainEvalHandle.reset_optimizer"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.reset_optimizer">[docs]</a>    <span class="k">def</span> <span class="nf">reset_optimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">:</span> <span class="n">ResettableOptimizer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Move model to correct device, init optimizer to parameters of model.</span>
<span class="sd">        By default apply to :py:attr:`optimizer`, :py:attr:`device`,</span>
<span class="sd">        :py:attr:`model`.&quot;&quot;&quot;</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optimizer</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">model</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">device</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span>

        <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optimizer</span><span class="p">:</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">init</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">optimizer</span></div>

<div class="viewcode-block" id="TrainEvalHandle.reset_training_handles"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.reset_training_handles">[docs]</a>    <span class="k">def</span> <span class="nf">reset_training_handles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">optimizer</span><span class="p">:</span> <span class="n">ResettableOptimizer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;(Re)set all handles associated with training, and move to ``device``.</span>
<span class="sd">        These are: :py:attr:`optimizer`, :py:attr:`early_stopping_handle`,</span>
<span class="sd">        and the data loaders.</span>
<span class="sd">        The argument values default to the corresponding attributes of this</span>
<span class="sd">        instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_optimizer</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">early_stopping_handle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">early_stopping_handle</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>

<div class="viewcode-block" id="TrainEvalHandle.reset_kpis"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.reset_kpis">[docs]</a>    <span class="k">def</span> <span class="nf">reset_kpis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">kpis</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">aggregating_kpis</span><span class="o">.</span><span class="n">AggregatingKpi</span><span class="p">,</span>
                                         <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
                                                  <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
                   <span class="p">):</span>  <span class="c1"># pylint: disable=no-self-use</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets aggregating kpis</span>

<span class="sd">        :param kpis: All metric functions and classes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kpis</span> <span class="o">=</span> <span class="n">kpis</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpi_fns</span>
        <span class="k">for</span> <span class="n">metric_fn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">fn</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">kpis</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                          <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">aggregating_kpis</span><span class="o">.</span><span class="n">filter_aggregating_kpi_keys</span><span class="p">(</span><span class="n">kpis</span><span class="p">)]:</span>
            <span class="n">metric_fn</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>

<div class="viewcode-block" id="TrainEvalHandle.train"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">train_loader</span><span class="p">:</span> <span class="n">DataLoader</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">val_loader</span><span class="p">:</span> <span class="n">DataLoader</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">pbar_desc_templ</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Epoch </span><span class="si">{epoch}</span><span class="s2">/</span><span class="si">{epochs}</span><span class="s2">&quot;</span><span class="p">,</span>
              <span class="n">callback_context</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Train the model according to the specified training parameters.</span>
<span class="sd">        Defaults are taken from :py:attr:`settings`.</span>
<span class="sd">        To override specify ``custom_args`` (compare arguments to</span>
<span class="sd">        :py:attr:`train_val_one_epoch`).</span>

<span class="sd">        :param callback_context: see :py:attr:`callback_context`</span>
<span class="sd">        :param pbar_desc_templ: template for the progress bar description;</span>
<span class="sd">            must accept as substring</span>

<span class="sd">            - ``{epoch}``: the current epoch number</span>
<span class="sd">            - ``{tot_epoch}``: the total number of epochs</span>
<span class="sd">        :param train_loader: see :py:meth:`train_one_epoch`</span>
<span class="sd">        :param val_loader: see :py:meth:`evaluate`</span>
<span class="sd">        :return: Two `pandas.DataFrame` with history information on</span>

<span class="sd">            - *training*: the epoch- and batch-wise loss and KPI results on the</span>
<span class="sd">              training data,</span>
<span class="sd">              index is a multi-index of ``(epoch, batch)``;</span>
<span class="sd">            - *test*: the epoch-wise evaluation results on the test set;</span>
<span class="sd">              index is the epoch index;</span>

<span class="sd">            columns for both are ``loss`` and KPI names</span>
<span class="sd">            (keys of :py:attr:`metric_fns`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># region Default values and value checks</span>
        <span class="n">_validate_templ</span><span class="p">(</span><span class="n">pbar_desc_templ</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;epoch&#39;</span><span class="p">,</span> <span class="s1">&#39;epochs&#39;</span><span class="p">))</span>

        <span class="n">callback_context</span> <span class="o">=</span> <span class="n">callback_context</span> <span class="ow">or</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_context</span><span class="p">}</span>
        <span class="c1"># Push model to correct device and reset training handles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_training_handles</span><span class="p">()</span>

        <span class="c1"># Shared loaders</span>
        <span class="n">train_loader</span><span class="p">:</span> <span class="n">DataLoader</span> <span class="o">=</span> \
            <span class="n">train_loader</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">train</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">val_loader</span><span class="p">:</span> <span class="n">DataLoader</span> <span class="o">=</span> \
            <span class="n">val_loader</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">val</span><span class="p">,</span>
                                      <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size_val</span><span class="p">)</span>
        <span class="c1"># endregion</span>

        <span class="n">history_train</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">history_val</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">):</span>
            <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">history_train</span><span class="o">=</span><span class="n">history_train</span><span class="p">,</span> <span class="n">history_val</span><span class="o">=</span><span class="n">history_val</span><span class="p">,</span>
                <span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                <span class="n">aggregating_kpis</span><span class="o">=</span><span class="n">aggregating_kpis</span><span class="o">.</span><span class="n">filter_aggregating_kpi_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric_fns</span><span class="p">))</span>
            <span class="c1"># Train and evaluate (with nice progress bar if requested)</span>
            <span class="n">kpis_train</span><span class="p">,</span> <span class="n">kpis_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_val_one_epoch</span><span class="p">(</span>
                <span class="n">train_loader</span><span class="o">=</span><span class="n">train_loader</span><span class="p">,</span> <span class="n">val_loader</span><span class="o">=</span><span class="n">val_loader</span><span class="p">,</span>
                <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
                <span class="n">pbar_desc</span><span class="o">=</span><span class="n">pbar_desc_templ</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                                 <span class="n">epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">),</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">epoch_end</span><span class="p">()</span>

            <span class="n">history_train</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span> <span class="o">=</span> <span class="n">kpis_train</span>
            <span class="n">history_val</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span> <span class="o">=</span> <span class="n">kpis_val</span>
            <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">history_train</span><span class="o">=</span><span class="n">history_train</span><span class="p">,</span>
                                    <span class="n">history_val</span><span class="o">=</span><span class="n">history_val</span><span class="p">)</span>
            <span class="c1"># Stop early if necessary</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">early_stopping_handle</span> <span class="ow">and</span>  <span class="c1"># TODO: integrate into callbacks</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">early_stopping_handle</span><span class="o">.</span><span class="n">step</span><span class="p">(</span>
                        <span class="n">kpis_val</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">val_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">LOSS_KEY</span><span class="p">)])):</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Stopped early after </span><span class="si">%d</span><span class="s2"> epochs.&quot;</span><span class="p">,</span> <span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">epoch</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">run_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">CallbackEvents</span><span class="o">.</span><span class="n">BETWEEN_EPOCHS</span><span class="p">,</span>
                              <span class="n">callback_context</span><span class="p">)</span>

        <span class="n">run_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">CallbackEvents</span><span class="o">.</span><span class="n">AFTER_TRAIN</span><span class="p">,</span>
                      <span class="n">callback_context</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">history_train</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">history_val</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>

<div class="viewcode-block" id="TrainEvalHandle.cross_validate"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.cross_validate">[docs]</a>    <span class="k">def</span> <span class="nf">cross_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_splits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                       <span class="n">train_val_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">run_info_templ</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Run </span><span class="si">{run}</span><span class="s1">/</span><span class="si">{runs}</span><span class="s1">&#39;</span><span class="p">,</span>
                       <span class="n">callback_context</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">pbar_desc_templ</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;epoch </span><span class="si">{epoch}</span><span class="s2">/</span><span class="si">{epochs}</span><span class="s2">&quot;</span><span class="p">,</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
                                       <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                                       <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Record training results for ``num_splits`` distinct val splits.</span>
<span class="sd">        The original model state dict is restored after training runs.</span>
<span class="sd">        The model must feature a ``reset_parameters()`` method to reinitialize</span>
<span class="sd">        between the runs.</span>

<span class="sd">        :param run_info_templ: template containing as substring placeholders</span>
<span class="sd">            ``{run}`` (the number of the current run) and ``runs``</span>
<span class="sd">            (the total number of runs);</span>
<span class="sd">            the template is used as prefix for logging and progress bars</span>
<span class="sd">        :param num_splits: number of equal-sized, distinct validation splits</span>
<span class="sd">            to use</span>
<span class="sd">        :param train_val_data: optional given dataset to split into train and</span>
<span class="sd">            validation dataset splits; defaults to the ``train_val`` split in</span>
<span class="sd">            :py:attr:`data`</span>
<span class="sd">        :param callback_context: current callback context to use;</span>
<span class="sd">            defaults to copy of :py:attr:`callback_context`</span>
<span class="sd">        :param pbar_desc_templ: template for progress bar description</span>
<span class="sd">            (prefixed by run information); see :py:meth:`train`</span>
<span class="sd">        :return: list of tuples of the form</span>

<span class="sd">            | (</span>
<span class="sd">            |     final ``state_dict``,</span>
<span class="sd">            |     epoch- and batch-wise train history as</span>
<span class="sd">                  :py:class:`pandas.DataFrame`,</span>
<span class="sd">            |     epoch-wise validation history as :py:class:`pandas.DataFrame`</span>
<span class="sd">            | )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{run}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">run_info_templ</span> <span class="ow">and</span> <span class="s2">&quot;</span><span class="si">{runs}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">run_info_templ</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;run_info_templ must contain formatting strings &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{run}</span><span class="s2"> and </span><span class="si">{runs}</span><span class="s2"> but was &quot;</span> <span class="o">+</span> <span class="n">run_info_templ</span><span class="p">)</span>
        <span class="c1"># region Default values</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;reset_parameters&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;model must feature a &#39;reset_parameters()&#39; method&quot;</span>
                             <span class="s2">&quot;for cross-validation&quot;</span><span class="p">)</span>
        <span class="n">train_val_data</span> <span class="o">=</span> <span class="n">train_val_data</span> <span class="k">if</span> <span class="n">train_val_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">train_val</span>
        <span class="n">callback_context</span> <span class="o">=</span> <span class="n">callback_context</span> <span class="ow">or</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_context</span><span class="p">}</span>

        <span class="c1"># end region</span>

        <span class="c1"># Save original model parameters:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">orig_state_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">())</span>

        <span class="n">splits</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Subset</span><span class="p">,</span> <span class="n">Subset</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="n">cross_validation_splits</span><span class="p">(</span><span class="n">train_val_data</span><span class="p">,</span> <span class="n">num_splits</span><span class="o">=</span><span class="n">num_splits</span><span class="p">)</span>
        <span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
                            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">run</span><span class="p">,</span> <span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">val_data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">splits</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">reset_parameters</span><span class="p">()</span>
            <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">run</span><span class="o">=</span><span class="n">run</span><span class="p">,</span> <span class="n">runs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">splits</span><span class="p">))</span>
            <span class="n">history_train</span><span class="p">,</span> <span class="n">history_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span>
                <span class="c1"># Use the created train val split</span>
                <span class="n">train_loader</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span><span class="n">train_data</span><span class="p">),</span>
                <span class="n">val_loader</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span><span class="n">val_data</span><span class="p">,</span>
                                       <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size_val</span><span class="p">),</span>
                <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
                <span class="c1"># TODO: integrate pbar_desc_templ into callback_context</span>
                <span class="n">pbar_desc_templ</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span>
                    <span class="n">run_info_templ</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">run</span><span class="o">=</span><span class="n">run</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">runs</span><span class="o">=</span><span class="n">num_splits</span><span class="p">)),</span>
                    <span class="n">pbar_desc_templ</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="c1"># collect the state dict</span>
            <span class="c1"># properly copy it and move to CPU to not overload GPU:</span>
            <span class="c1"># save results:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">detached_state_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span>
                            <span class="n">history_train</span><span class="p">,</span> <span class="n">history_val</span><span class="p">))</span>

        <span class="c1"># Restore original model parameters:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">orig_state_dict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="TrainEvalHandle.detached_state_dict"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.detached_state_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">detached_state_dict</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                            <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cpu&#39;</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a properly detached copy of the state dict of ``model``</span>
<span class="sd">        on ``device``.</span>
<span class="sd">        By default, the copy is created on ``cpu`` device to avoid</span>
<span class="sd">        overloading the GPU memory.&quot;&quot;&quot;</span>
        <span class="n">state_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">state_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> \
                <span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_dict</span></div>

<div class="viewcode-block" id="TrainEvalHandle.train_val_one_epoch"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.train_val_one_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">train_val_one_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">pbar_desc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">callback_context</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">train_loader</span><span class="p">:</span> <span class="n">DataLoader</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">val_loader</span><span class="p">:</span> <span class="n">DataLoader</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Train for one epoch, evaluate, and return history and test results.</span>
<span class="sd">        This is a wrapper around :py:meth:`train_one_epoch` and</span>
<span class="sd">        :py:meth:`evaluate` with nice progress bar printing and logging after</span>
<span class="sd">        the epoch.</span>
<span class="sd">        History and test results are stored in a :py:class:`pandas.DataFrame`.</span>
<span class="sd">        The device used for training is that of the parameters of the used</span>
<span class="sd">        model (see :py:func:`~hybrid_learning.concepts.train_eval.train_eval_funs.device_of`).</span>

<span class="sd">        :param pbar_desc: leading static description text for the progress bar</span>
<span class="sd">        :param callback_context: see :py:attr:`callback_context`</span>
<span class="sd">        :param train_loader: see :py:meth:`train_one_epoch`</span>
<span class="sd">        :param val_loader: see :py:meth:`evaluate`</span>
<span class="sd">        :return: tuple of training history and test results; columns resp.</span>
<span class="sd">            index are ``loss`` and the KPI names</span>
<span class="sd">            (keys from dict :py:attr:`metric_fns`).</span>

<span class="sd">            - :py:class:`pandas.DataFrame`: index are the batch indices,</span>
<span class="sd">              items are the results of KPI evaluations of the output on the</span>
<span class="sd">              training batch (i.e. before back-propagation step)</span>
<span class="sd">            - :py:class:`pandas.Series`: the items are the final evaluations of</span>
<span class="sd">              the KPIs on the validation set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callback_context</span> <span class="o">=</span> <span class="n">callback_context</span> <span class="ow">or</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_context</span><span class="p">}</span>
        <span class="n">pbar</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_show_progress_bars_for</span><span class="p">(</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TRAIN</span><span class="p">)</span> <span class="k">else</span> \
            <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="n">pbar_desc</span> <span class="ow">or</span> <span class="s2">&quot;Epoch&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">train_loader</span><span class="p">))</span>

        <span class="c1"># Training</span>
        <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span> <span class="n">batches</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">train_loader</span><span class="p">),</span> <span class="n">train_loader</span><span class="o">=</span><span class="n">train_loader</span><span class="p">)</span>
        <span class="n">train_kpi_vals</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_one_epoch</span><span class="p">(</span>
            <span class="n">train_loader</span><span class="o">=</span><span class="n">train_loader</span><span class="p">,</span>
            <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
            <span class="n">pbar_desc</span><span class="o">=</span><span class="n">pbar_desc</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">pbar</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_show_progress_bars_for</span><span class="p">(</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">VAL</span><span class="p">):</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pbar</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Evaluation</span>
        <span class="n">val_kpi_vals</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">VAL</span><span class="p">,</span>
                          <span class="n">val_loader</span><span class="o">=</span><span class="n">val_loader</span><span class="p">,</span>
                          <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
                          <span class="n">pbar_desc</span><span class="o">=</span><span class="n">pbar_desc</span><span class="p">))</span>

        <span class="c1"># Logging</span>
        <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">kpi_train</span><span class="o">=</span><span class="n">train_kpi_vals</span><span class="p">,</span> <span class="n">kpi_val</span><span class="o">=</span><span class="n">val_kpi_vals</span><span class="p">)</span>
        <span class="n">run_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">CallbackEvents</span><span class="o">.</span><span class="n">AFTER_EPOCH</span><span class="p">,</span>
                      <span class="n">callback_context</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">train_kpi_vals</span><span class="p">,</span> <span class="n">val_kpi_vals</span></div>

<div class="viewcode-block" id="TrainEvalHandle.train_one_epoch"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.train_one_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">train_one_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">train_loader</span><span class="p">:</span> <span class="n">DataLoader</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">callback_context</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">pbar_desc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Train progress&quot;</span><span class="p">,</span>
                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Train for one epoch and return history results as</span>
<span class="sd">        :py:class:`pandas.DataFrame`.</span>
<span class="sd">        This is a wrapper around</span>
<span class="sd">        :py:func:`hybrid_learning.concepts.train_eval.train_eval_funs.train_one_epoch`</span>
<span class="sd">        that uses defaults from :py:attr:`settings`.</span>

<span class="sd">        :param train_loader: the training loader to use;</span>
<span class="sd">            defaults to a shuffled one with training :py:attr:`data` of ``self``</span>
<span class="sd">        :param callback_context: see :py:attr:`callback_context`</span>
<span class="sd">        :param pbar_desc: leading static description text for the progress bar</span>
<span class="sd">            if newly created</span>
<span class="sd">        :return: tuple of training history and test results as</span>
<span class="sd">            :py:class:`pandas.DataFrame` with:</span>

<span class="sd">            :columns:</span>
<span class="sd">                ``loss`` and the KPI names</span>
<span class="sd">                (keys from dict :py:attr:`metric_fns`),</span>
<span class="sd">            :index: the batch indices,</span>
<span class="sd">            :items:</span>
<span class="sd">                the results of KPI evaluations of the output on the training</span>
<span class="sd">                batch (i.e. *before* back-propagation step)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot train without loss_fn (was not given during init)!&quot;</span><span class="p">)</span>
        <span class="n">callback_context</span> <span class="o">=</span> <span class="n">callback_context</span> <span class="ow">or</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_context</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_kpis</span><span class="p">()</span>
        <span class="n">train_loader</span> <span class="o">=</span> <span class="n">train_loader</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">train</span><span class="p">,</span>
                                                   <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Progressbar handling</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback_context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pbar&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_show_progress_bars_for</span><span class="p">(</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TRAIN</span><span class="p">):</span>
            <span class="n">callback_context</span><span class="p">[</span><span class="s1">&#39;pbar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="n">pbar_desc</span><span class="p">,</span>
                                            <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">train_loader</span><span class="p">))</span>

        <span class="c1"># Actual training</span>
        <span class="k">return</span> <span class="n">train_one_epoch</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
            <span class="n">loss_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span><span class="p">,</span>
            <span class="n">metric_fns</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">fn</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpi_fns</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOSS_KEY</span><span class="p">},</span>  <span class="c1"># add nll_fn to metrics</span>
            <span class="n">train_loader</span><span class="o">=</span><span class="n">train_loader</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">callbacks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">,</span>
            <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
            <span class="c1"># ensemble_count=self.ensemble_count,  # TODO: support ensembles</span>
            <span class="n">loss_key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">LOSS_KEY</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TrainEvalHandle.evaluate"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DatasetSplit</span><span class="p">]</span> <span class="o">=</span> <span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span>
                 <span class="n">val_loader</span><span class="p">:</span> <span class="n">DataLoader</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">callback_context</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">pbar_desc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Progress&quot;</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the model wrt. :py:attr:`settings`.</span>
<span class="sd">        This is a wrapper around</span>
<span class="sd">        :py:func:`~hybrid_learning.concepts.train_eval.train_eval_funs.evaluate` which</span>
<span class="sd">        uses the defaults given by :py:attr:`settings`.</span>
<span class="sd">        Override them by specifying them as ``custom_args``.</span>
<span class="sd">        The device used for evaluation is :py:attr:`device` or the one of the</span>
<span class="sd">        model.</span>

<span class="sd">        :param mode: see :py:attr:`loader`</span>
<span class="sd">        :param prefix: see</span>
<span class="sd">            :py:func:`~hybrid_learning.concepts.train_eval.train_eval_funs.evaluate`</span>
<span class="sd">        :param val_loader: the evaluation dataset loader;</span>
<span class="sd">            defaults to one with :py:attr:`data` of respective ``mode``</span>
<span class="sd">        :param callback_context: see :py:attr:`callback_context`</span>
<span class="sd">        :param pbar_desc: leading static description text for the progress bar</span>
<span class="sd">            if newly created</span>
<span class="sd">        :return: Dictionary of all KPIs, i.e. of ``loss`` and each metric</span>
<span class="sd">            in :py:attr:`metric_fns`;</span>
<span class="sd">            format: ``{&lt;KPI-name&gt;: &lt;KPI value as float&gt;}``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callback_context</span> <span class="o">=</span> <span class="n">callback_context</span> <span class="ow">or</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_context</span><span class="p">}</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">DatasetSplit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_validated_split</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">val_loader</span> <span class="o">=</span> <span class="n">val_loader</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                                               <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size_val</span><span class="p">)</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Progressbar handling</span>
        <span class="n">pbar_eval</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_show_progress_bars_for</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
            <span class="n">pbar_eval</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pbar_desc</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">mode</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">val_loader</span><span class="p">))</span>
            <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pbar_eval</span><span class="o">=</span><span class="n">pbar_eval</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset_kpis</span><span class="p">()</span>
        <span class="n">results</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
            <span class="n">kpi_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kpi_fns</span><span class="p">,</span>
            <span class="n">val_loader</span><span class="o">=</span><span class="n">val_loader</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
            <span class="n">callbacks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">,</span>
            <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
            <span class="c1"># ensemble_count = self.ensemble_count,  # TODO: support ensembles</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">pbar_eval</span><span class="p">:</span>
            <span class="n">pbar_eval</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="TrainEvalHandle.second_stage_train"><a class="viewcode-back" href="../../../../../apiref/generated/hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.html#hybrid_learning.concepts.train_eval.base_handles.train_test_handle.TrainEvalHandle.second_stage_train">[docs]</a>    <span class="k">def</span> <span class="nf">second_stage_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">callback_context</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Do a second stage training for calibration using Laplace</span>
<span class="sd">        approximation. This is a wrapper around</span>
<span class="sd">        :py:func:`hybrid_learning.concepts.train_eval.train_eval_funs.second_stage_train`</span>
<span class="sd">        that uses defaults from :py:attr:`settings`.</span>
<span class="sd">        Before and after the second stage training process one epoch</span>
<span class="sd">        on the test and the validation set to enable logging of metrics</span>
<span class="sd">        for comparison.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Evaluation runs on validation and test split are conducted</span>
<span class="sd">            before (epoch 0) and after (epoch 1) the second stage training.</span>

<span class="sd">        :param callback_context: see :py:attr:`callback_context`.</span>
<span class="sd">        :return: py:class:`pandas.Series` with the final evaluation results</span>
<span class="sd">            on validation and test splits of :py:attr:`data`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">callback_context</span> <span class="o">=</span> <span class="n">callback_context</span> <span class="ow">or</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_context</span><span class="p">}</span>
        <span class="c1"># region Run callbacks for validation results BEFORE second stage train</span>
        <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">epoch</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">,</span>  <span class="c1"># log before status as epoch 0</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">val_kpi_vals</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">VAL</span><span class="p">,</span>
            <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">VAL</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">Cal&quot;</span><span class="p">)</span>

        <span class="n">test_kpi_vals</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span>
            <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TEST</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">Cal&quot;</span><span class="p">)</span>

        <span class="n">val_kpi_vals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">val_kpi_vals</span><span class="p">,</span> <span class="n">test_kpi_vals</span><span class="p">])</span>
        <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kpi_val</span><span class="o">=</span><span class="n">val_kpi_vals</span><span class="p">)</span>
        <span class="c1"># endregion</span>

        <span class="n">second_stage_train</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
            <span class="n">nll_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nll_fn</span><span class="p">,</span>
            <span class="n">train_loader</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">train</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size_hessian</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device_of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span>
                <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">val_loader</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">val</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size_val</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device_of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span>
                <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># region: Run callbacks for validation results AFTER second stage train</span>
        <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">epoch</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">,</span>  <span class="c1"># log after status as epoch 1</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">val_kpi_vals</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">VAL</span><span class="p">,</span>
            <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">VAL</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">Cal&quot;</span><span class="p">)</span>

        <span class="n">test_kpi_vals</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span>
            <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">DatasetSplit</span><span class="o">.</span><span class="n">TEST</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">Cal&quot;</span><span class="p">)</span>

        <span class="n">val_kpi_vals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">val_kpi_vals</span><span class="p">,</span> <span class="n">test_kpi_vals</span><span class="p">])</span>
        <span class="n">callback_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kpi_val</span><span class="o">=</span><span class="n">val_kpi_vals</span><span class="p">)</span>

        <span class="n">run_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">CallbackEvents</span><span class="o">.</span><span class="n">AFTER_SECOND_STAGE_TRAIN</span><span class="p">,</span>
                      <span class="n">callback_context</span><span class="o">=</span><span class="n">callback_context</span><span class="p">)</span>
        <span class="c1"># endregion</span>

        <span class="k">return</span> <span class="n">val_kpi_vals</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Continental Automotive GmbH.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>