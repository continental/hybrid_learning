

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hybrid_learning.concepts.embeddings &mdash; hybrid_learning  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/autoclasstoc.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> hybrid_learning
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Content</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apiref/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">How to contribute</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">hybrid_learning</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>hybrid_learning.concepts.embeddings</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for hybrid_learning.concepts.embeddings</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Representation of concept embeddings and modification functions.&quot;&quot;&quot;</span>
<span class="c1">#  Copyright (c) 2020 Continental Automotive GmbH</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> \
    <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch.nn</span>

<span class="kn">from</span> <span class="nn">.concepts</span> <span class="kn">import</span> <span class="n">Concept</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="c1"># avoid cyclic import for the typing stuff</span>
    <span class="kn">from</span> <span class="nn">.models.model_extension</span> <span class="kn">import</span> <span class="n">ModelStump</span>


<span class="c1"># noinspection PyArgumentEqualDefault</span>
<div class="viewcode-block" id="ConceptEmbedding"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding">[docs]</a><span class="k">class</span> <span class="nc">ConceptEmbedding</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Representation of an embedding of a concept within a DNN.</span>
<span class="sd">    The representation aims to be technology independent.</span>

<span class="sd">    Main aspects:</span>

<span class="sd">    - the parameters:</span>
<span class="sd">      :math:`\text{concept vector} = \text{weight}`,</span>
<span class="sd">      :math:`\text{bias} = -\text{threshold}`</span>
<span class="sd">    - the layer it is attached to given by the model up to that layer.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">concept_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Shortcut to the name of the concept that is embedded.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concept_name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">layer_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The layer in the main model in which the concept is embedded.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_stump</span><span class="o">.</span><span class="n">stump_head</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_stump</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">main_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The main torch model in which the concept is embedded.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_stump</span><span class="o">.</span><span class="n">wrapped_model</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_stump</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

<div class="viewcode-block" id="ConceptEmbedding.scale"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new equivalent embedding with ``scaling_factor == 1``.&quot;&quot;&quot;</span>
        <span class="n">scaled_normal_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span>
        <span class="n">scaled_support_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span>
        <span class="k">return</span> <span class="n">ConceptEmbedding</span><span class="p">(</span><span class="n">normal_vec</span><span class="o">=</span><span class="n">scaled_normal_vec</span><span class="p">,</span>
                                <span class="n">support_factor</span><span class="o">=</span><span class="n">scaled_support_factor</span><span class="p">,</span>
                                <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_info</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConceptEmbedding.save"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the embedding parameters and some description as npz file.</span>
<span class="sd">        The file contains values for the following keys:</span>
<span class="sd">        ``normal_vec``, ``scaling_factor``, ``support_factor``,</span>
<span class="sd">        ``concept_name``, ``layer_id``.</span>
<span class="sd">        Load the embedding using :py:meth:`load`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;w+b&#39;</span> <span class="k">if</span> <span class="n">overwrite</span> <span class="k">else</span> <span class="s1">&#39;xb&#39;</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">normal_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">,</span>
                        <span class="n">support_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span><span class="p">,</span>
                        <span class="n">scaling_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span><span class="p">,</span>
                        <span class="n">concept_name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_name</span><span class="p">),</span>
                        <span class="n">layer_id</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer_id</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">npz_file</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">npz_file</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConceptEmbedding.load"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load an embedding.</span>
<span class="sd">        The format should be as used by :py:meth:`save`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meta_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Meta information about the embedding (model and concept).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">concept</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">concept</span><span class="p">,</span>
                    <span class="n">model_stump</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_stump</span><span class="p">,</span>
                    <span class="n">concept_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_name</span><span class="p">,</span>
                    <span class="n">layer_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer_id</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">settings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary to reproduce the instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">normal_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">,</span>
                    <span class="n">support_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span><span class="p">,</span>
                    <span class="n">scaling_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span><span class="p">,</span>
                    <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_info</span><span class="p">)</span>

<div class="viewcode-block" id="ConceptEmbedding.__init__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normal_vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">support_factor</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">scaling_factor</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
                 <span class="n">concept</span><span class="p">:</span> <span class="n">Concept</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">model_stump</span><span class="p">:</span> <span class="s1">&#39;ModelStump&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">concept_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">layer_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Init.</span>

<span class="sd">        :param concept: the concept that is embedded</span>
<span class="sd">        :param model_stump: the model up to the layer of the embedding</span>
<span class="sd">        :param normal_vec: the concept vector</span>
<span class="sd">        :param support_factor: the negative concept threshold</span>
<span class="sd">        :param layer_id: if ``model_stump`` is not given, optional</span>
<span class="sd">            specification of the ``layer_id``</span>
<span class="sd">        :param concept_name: if ``concept`` is not given,</span>
<span class="sd">            optional specification of the name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concept</span><span class="p">:</span> <span class="n">Concept</span> <span class="o">=</span> <span class="n">concept</span>
        <span class="sd">&quot;&quot;&quot;The concept that is embedded.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_concept_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">concept_name</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept</span><span class="o">.</span><span class="n">name</span>
        <span class="sd">&quot;&quot;&quot;If the concept is not given, identifier for the concept used in</span>
<span class="sd">        :py:attr`concept_name`&quot;&quot;&quot;</span>

        <span class="c1"># where the concept model is attached</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_stump</span><span class="p">:</span> <span class="s1">&#39;ModelStump&#39;</span> <span class="o">=</span> <span class="n">model_stump</span>
        <span class="sd">&quot;&quot;&quot;The head of the model and the layer the concept is embedded into.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">layer_id</span><span class="p">)</span> <span class="k">if</span> <span class="n">model_stump</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;If the model stump is not given, the layer ID used in</span>
<span class="sd">        :py:attr:`layer_id`&quot;&quot;&quot;</span>

        <span class="c1"># parameters of the concept model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">normal_vec</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A normal vector to the represented hyperplane.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">support_factor</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A factor :math:`b` to obtain the orthogonal support vector</span>
<span class="sd">        :math:`b\cdot n` from the normal vector :math:`n`.</span>
<span class="sd">        A vector :math:`v` is on the hyperplane iff</span>

<span class="sd">        .. math:: 0 = d(v) = (v - b\cdot n) \circ n = v \circ n - b\cdot |n|^2</span>

<span class="sd">        Here, :math:`d(v)` denotes the signed orthogonal distance of :math:`v`</span>
<span class="sd">        from the hyperplane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;Got bias which has more than one entry (shape: </span><span class="si">{}</span><span class="s2">): </span><span class="si">{}</span><span class="s2">&quot;</span>
                 <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">support_factor</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">support_factor</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">scaling_factor</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The factor to obtain the original weight vector.</span>
<span class="sd">        Any two embeddings with normal vectors :math:`n_1, n_2` and support</span>
<span class="sd">        factors :math:`b_1, b_2` fulfilling the following represent the same</span>
<span class="sd">        hyperplane:</span>

<span class="sd">        .. math::</span>
<span class="sd">            :nowrap:</span>

<span class="sd">            \begin{align*}</span>
<span class="sd">            \frac{|n_1 \circ n_2|} {(|n_1| \cdot |n_2|)} &amp;= 1 &amp;\text{and} &amp;&amp;</span>
<span class="sd">            \frac{|n_1|} {|n_2|} &amp;= \frac{b_2} {b_1}</span>
<span class="sd">            \end{align*}</span>

<span class="sd">        However, the signed orthogonal distance measure of an embedding</span>
<span class="sd">        :math:`(n, b)` for a vector :math:`v`</span>

<span class="sd">        .. math::</span>
<span class="sd">            d(v)</span>
<span class="sd">            = (v - b \cdot n) \circ n</span>
<span class="sd">            = |n| \cdot \left(v \circ \frac{n}{|n|}\right) - b\cdot|n|^2</span>

<span class="sd">        which is used e.g. in concept layers, depends quadratic on the normal</span>
<span class="sd">        vector length. If the hyperplane representation is changed,</span>
<span class="sd">        the original normal vector and support factor</span>
<span class="sd">        providing the original distance measure can be obtained via</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left(n \cdot \text{scaling_factor} ,</span>
<span class="sd">            \frac{b}{\text{scaling_factor}})\right.</span>

<span class="sd">        *Examples:*</span>
<span class="sd">        The scaling_factor is 1 if the original weight was not changed,</span>
<span class="sd">        and :math:`|weight|` if it was normalized.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ConceptEmbedding.distance"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.distance">[docs]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calc the scaled distance of point from the embedding hyperplane.</span>
<span class="sd">        The distance from a point pt is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            d(pt) =</span>
<span class="sd">            \text{scaling_factor} \cdot \left((n \circ pt)</span>
<span class="sd">            - b (n \circ n)\right)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;Cannot calculate distance for point of different&quot;</span>
                              <span class="s2">&quot; shape than normal vec; expected </span><span class="si">{}</span><span class="s2"> but was </span><span class="si">{}</span><span class="s2">&quot;</span>
                              <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="c1"># d(pt) = scaling_factor * [(n \circ pt) - b * (n \circ n)]</span>
        <span class="n">dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">*</span>
                       <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">point</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">)</span>
                        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConceptEmbedding.normalize"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Yield a new, equivalent embedding with normalized normal vec.</span>
<span class="sd">        The sign of the scaling factor is not changed.&quot;&quot;&quot;</span>
        <span class="n">normal_vec_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">normal_vec_norm</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tried to normalize zero vector.&quot;</span><span class="p">)</span>
        <span class="n">normed_normal_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span> <span class="o">/</span> <span class="n">normal_vec_norm</span>
        <span class="n">normed_scaling_factor</span> <span class="o">=</span> <span class="n">normal_vec_norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span>
        <span class="n">normed_support_factor</span> <span class="o">=</span> <span class="n">normal_vec_norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span>
        <span class="k">return</span> <span class="n">ConceptEmbedding</span><span class="p">(</span><span class="n">normal_vec</span><span class="o">=</span><span class="n">normed_normal_vec</span><span class="p">,</span>
                                <span class="n">support_factor</span><span class="o">=</span><span class="n">normed_support_factor</span><span class="p">,</span>
                                <span class="n">scaling_factor</span><span class="o">=</span><span class="n">normed_scaling_factor</span><span class="p">,</span>
                                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_info</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConceptEmbedding.unique"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.unique">[docs]</a>    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Yield new, equivalent, unique embedding with normalized normal vec</span>
<span class="sd">        and pos scaling.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span><span class="o">.</span><span class="n">to_pos_scaling</span><span class="p">()</span></div>

<div class="viewcode-block" id="ConceptEmbedding.unique_upper_sphere"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.unique_upper_sphere">[docs]</a>    <span class="k">def</span> <span class="nf">unique_upper_sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Yield new equivalent, unique embedding with normal vec normalized</span>
<span class="sd">        in upper hemisphere.</span>

<span class="sd">        An embedding defines a hyperplane as follows:</span>

<span class="sd">        - the :math:`weight` is a (not necessarily normalized) normal vector</span>
<span class="sd">          of the hyperplane</span>
<span class="sd">        - :math:`bias \cdot weight` is a support vector orthogonal to the plane</span>

<span class="sd">        This representation is not unique.</span>
<span class="sd">        In many cases it is desirable to consider the representation where</span>
<span class="sd">        the normal vector is normalized, and lies on the upper half of a</span>
<span class="sd">        given sphere (including the equator). To also obtain unique results</span>
<span class="sd">        for the equator cases, the rule is that, when flattened, the first</span>
<span class="sd">        non-zero entry is positive.</span>
<span class="sd">        The representation obtained then as follows is unique</span>
<span class="sd">        (sign(weight) is the sign of the first non-zero entry when flattened):</span>

<span class="sd">        .. math::</span>
<span class="sd">            weight_{new} &amp;= sign(weight) \cdot \frac{weight} {|weight|} \\</span>
<span class="sd">            bias_{new}   &amp;= sign(weight) \cdot (bias \cdot |weight|)</span>

<span class="sd">        Then the weight is normalized and</span>

<span class="sd">        .. math:: weight_{new} \cdot bias_{new} = weight \cdot bias</span>

<span class="sd">        is still an orthogonal support vector.</span>
<span class="sd">        Two equivalent representations will yield the same such</span>
<span class="sd">        normalized embedding.</span>

<span class="sd">        :returns: Equivalent embedding where the weight of the output embedding</span>
<span class="sd">            is normalized and, when flattened, the weight&#39;s first non-zero</span>
<span class="sd">            entry is positive</span>
<span class="sd">        :raises: :py:exc:`ValueError`, if the weight of the embedding is zero</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normalize the weight and the bias</span>
        <span class="n">normed_emb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

        <span class="c1"># Now reflect weight if it is on the wrong side of the hemisphere</span>
        <span class="c1"># Sign of first non-zero entry</span>
        <span class="n">first_weight_sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span>
            <span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">normed_emb</span><span class="o">.</span><span class="n">normal_vec</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
             <span class="k">if</span> <span class="n">entry</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">normed_emb</span><span class="o">.</span><span class="n">support_factor</span> <span class="o">*=</span> <span class="n">first_weight_sign</span>
        <span class="n">normed_emb</span><span class="o">.</span><span class="n">normal_vec</span> <span class="o">*=</span> <span class="n">first_weight_sign</span>
        <span class="n">normed_emb</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">*=</span> <span class="n">first_weight_sign</span>

        <span class="k">return</span> <span class="n">normed_emb</span></div>

<div class="viewcode-block" id="ConceptEmbedding.to_pos_scaling"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.to_pos_scaling">[docs]</a>    <span class="k">def</span> <span class="nf">to_pos_scaling</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the representation of this embedding with positive scaling.&quot;&quot;&quot;</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mf">1.</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="k">return</span> <span class="n">ConceptEmbedding</span><span class="p">(</span><span class="n">normal_vec</span><span class="o">=</span><span class="n">sign</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">,</span>
                                <span class="n">support_factor</span><span class="o">=</span><span class="n">sign</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span><span class="p">,</span>
                                <span class="n">scaling_factor</span><span class="o">=</span><span class="n">sign</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span><span class="p">,</span>
                                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_info</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConceptEmbedding.forget_scaling"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.forget_scaling">[docs]</a>    <span class="k">def</span> <span class="nf">forget_scaling</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the embedding with the same normal vec and support but</span>
<span class="sd">        scaling factor 1.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ConceptEmbedding</span><span class="p">(</span><span class="n">normal_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">,</span>
                                <span class="n">support_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span><span class="p">,</span>
                                <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_info</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConceptEmbedding.mean"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.mean">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the normalized embedding with distance fctn mean of the</span>
<span class="sd">        normalized distance fctns.</span>
<span class="sd">        Consider the non-scaled distance functions of the normalized versions</span>
<span class="sd">        of the given embeddings. Then the condition for the normalized mean</span>
<span class="sd">        embedding is that at any point the distance from the embedding</span>
<span class="sd">        hyperplane to the point is the mean distance of these normalized</span>
<span class="sd">        distances:</span>

<span class="sd">        .. math::</span>
<span class="sd">            d_{\frac{n}{|n|}, b\cdot |n|}</span>
<span class="sd">            = mean\left( d_{\frac{n_j}{|n_j|}, |n_j|\cdot b_j} \right)</span>

<span class="sd">        The scaling factor in the end is the mean of the scaling factors of</span>
<span class="sd">        the normalized representations of the given embeddings.</span>

<span class="sd">        :returns: normalized</span>
<span class="sd">        :raises: :py:exc:`ValueError` if</span>
<span class="sd">            :math:`mean\left(\frac{n_j}{|n_j|}\right)` of the scaled</span>
<span class="sd">            normal vectors :math:`n_j` is 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Value checks:</span>
        <span class="c1"># Check embeddings length</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_validate_embedding_list</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span>

        <span class="c1"># Get normalized versions of embeddings with positive scaling factor</span>
        <span class="n">normed_embs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span><span class="o">.</span><span class="n">to_pos_scaling</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">embeddings</span><span class="p">]</span>
        <span class="n">scaling_factors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">scaling_factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">normed_embs</span><span class="p">]</span>
        <span class="c1"># Set scaling factors to 1. to make .scale() have no effect</span>
        <span class="n">normed_unscaled_embs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ConceptEmbedding</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">forget_scaling</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span>
                                                        <span class="ow">in</span> <span class="n">normed_embs</span><span class="p">]</span>

        <span class="c1"># Now calculate distance mean and normalize normal vector</span>
        <span class="n">mean_embedding</span><span class="p">:</span> <span class="n">ConceptEmbedding</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mean_by_distance</span><span class="p">(</span>
            <span class="n">normed_unscaled_embs</span><span class="p">)</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="c1"># The scaling_factor should be the mean of the given scaling factors:</span>
        <span class="n">mean_embedding</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scaling_factors</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mean_embedding</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_embedding_list</span><span class="p">(</span><span class="n">embeddings</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">]</span>
                                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check whether given embeddings list is suitable for calculating a</span>
<span class="sd">        mean.</span>

<span class="sd">        :raises: :py:exc:`ValueError` if any condition is not fulfilled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check embeddings length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Got empty list of embeddings for calculating &quot;</span>
                             <span class="s2">&quot;mean.&quot;</span><span class="p">)</span>
        <span class="c1"># Check that all use the same concept</span>
        <span class="n">concept</span><span class="p">:</span> <span class="n">Concept</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">concept</span>
        <span class="k">for</span> <span class="n">emb</span> <span class="ow">in</span> <span class="n">embeddings</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">concept</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">emb</span><span class="o">.</span><span class="n">concept</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;Called mean on embeddings of different &quot;</span>
                                  <span class="s2">&quot;concepts (</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">)&quot;</span>
                                  <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">concept</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">emb</span><span class="o">.</span><span class="n">concept</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

<div class="viewcode-block" id="ConceptEmbedding.mean_by_distance"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.mean_by_distance">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">mean_by_distance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>  <span class="c1"># TODO: optional weighting?</span>
                         <span class="n">embeddings</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">]</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get embedding with distance measure being the mean of given embs.</span>
<span class="sd">        This routine only works if the mean of the scaled embeddings normal</span>
<span class="sd">        vectors is non-zero.</span>

<span class="sd">        The distance of a point :math:`x` from a hyperplane :math:`(n, b)`</span>
<span class="sd">        with normal vector :math:`n` and support vector :math:`b\cdot n` is</span>
<span class="sd">        defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            d_{n,b}(x)</span>
<span class="sd">            = \left((x - b\cdot n) \circ n\right)</span>
<span class="sd">            = x \circ n - b \cdot |n|^2</span>

<span class="sd">        For an embedding :math:`(n, b, s)` with scaling factor s the distance</span>
<span class="sd">        measure is the one of its scaled version :math:`(s n, \frac{b}{s}, 1)`,</span>
<span class="sd">        which turns out to be</span>

<span class="sd">        .. math:: d_{s n, \frac{b}{s}} = s \cdot d_{n,b}</span>

<span class="sd">        This routine determines the &quot;average&quot; hyperplane for the given</span>
<span class="sd">        embeddings, where here average hyperplane :math:`(n, b)` means the</span>
<span class="sd">        one with the following property:</span>

<span class="sd">        .. math::</span>
<span class="sd">            d_{n,b}</span>
<span class="sd">            = mean(d_{n_j,b_j})</span>
<span class="sd">            = \frac 1 N \sum_{j=1}^{N} d_{n_j,b_j}</span>

<span class="sd">        i.e. at any point :math:`x` in space the distance of the average</span>
<span class="sd">        hyperplane to :math:`x` is the mean of the distances of all N given</span>
<span class="sd">        hyperplanes :math:`(n_j,b_j)` to :math:`x`. It is unique (the points</span>
<span class="sd">        on the plane are those with distance 0 and thus all the same),</span>
<span class="sd">        and given by the following combination (with scaling factor 1):</span>

<span class="sd">        .. math::</span>
<span class="sd">            n &amp;= mean(n_j) \\</span>
<span class="sd">            b &amp;= \frac{1}{|n|^2} mean(b_j \cdot |n_j|^2)</span>

<span class="sd">        Possible problems: This will weight the contribution of the given</span>
<span class="sd">        embeddings by their confidence, i.e. their scaling factor.</span>
<span class="sd">        To avoid this, the mean can be taken over the normalized versions</span>
<span class="sd">        with scaling factor set to one and the scaling factor of the mean can</span>
<span class="sd">        be determined by confidence calibration.</span>

<span class="sd">        :returns: embedding describing the hyperplane with above properties</span>
<span class="sd">        :raises: ValueError if the mean of the scaled normal vectors of the</span>
<span class="sd">            given embeddings is 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Value checks:</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_validate_embedding_list</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span>
        <span class="n">meta_info</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">meta_info</span>

        <span class="c1"># First apply the scaling to all embeddings</span>
        <span class="n">scaled_embeddings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ConceptEmbedding</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">scale</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">embeddings</span><span class="p">]</span>
        <span class="n">normal_vecs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">normal_vec</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">scaled_embeddings</span><span class="p">]</span>
        <span class="n">support_factors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">support_factor</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">scaled_embeddings</span><span class="p">]</span>

        <span class="c1"># Normal vector: mean(n_j) with n_j scaled normal vectors</span>
        <span class="n">mean_normal_vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">normal_vecs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Get normal vector norm; must not be zero!</span>
        <span class="n">squared_mean_normal_vec_norm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mean_normal_vec</span> <span class="o">*</span> <span class="n">mean_normal_vec</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">squared_mean_normal_vec_norm</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mean of scaled embedding normal vectors is zero; &quot;</span>
                             <span class="s2">&quot;cannot calculate mean embedding&quot;</span><span class="p">)</span>

        <span class="c1"># Support factor: - b = mean(b_j * |n_j|**2) / (|n|**2)</span>
        <span class="c1"># with b_j scaled support factor, n mean normal vector</span>
        <span class="n">mean_support_factor</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> \
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_j</span> <span class="o">*</span> <span class="n">n_j</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">n_j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">support_factors</span><span class="p">,</span> <span class="n">normal_vecs</span><span class="p">)])</span>
             <span class="o">/</span> <span class="n">squared_mean_normal_vec_norm</span><span class="p">)</span>

        <span class="n">mean_embedding</span><span class="p">:</span> <span class="n">ConceptEmbedding</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">normal_vec</span><span class="o">=</span><span class="n">mean_normal_vec</span><span class="p">,</span>
            <span class="n">support_factor</span><span class="o">=</span><span class="n">mean_support_factor</span><span class="p">,</span>
            <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
            <span class="o">**</span><span class="n">meta_info</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mean_embedding</span></div>

<div class="viewcode-block" id="ConceptEmbedding.variance"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.variance">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">variance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">],</span> <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the variance of a list of embeddings (by default unbiased).</span>
<span class="sd">        The variances are calculated on the unique normalized representations</span>
<span class="sd">        of the embeddings, and encompass variance of:</span>

<span class="sd">        - the normal vector</span>
<span class="sd">        - the support vector factor (= distance to 0)</span>
<span class="sd">        - the scaling factor (= length of the normal vector).</span>

<span class="sd">        :param embeddings: sequence of embeddings to take variance of</span>
<span class="sd">        :param ddof: delta degrees of freedom: the divisor used in calculations</span>
<span class="sd">            is :math:`\text{num_embeddings} - \text{ddof}`;</span>
<span class="sd">            if ``ddof=1`` (default), the unbiased variance is obtained</span>
<span class="sd">        :returns: Tuple of variance of</span>
<span class="sd">            ``(normal vecs, support factors, scaling factors)`` for</span>
<span class="sd">            normalized representations of given embeddings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First norm all embeddings and bring them to the same hemisphere to</span>
        <span class="c1"># compare them</span>
        <span class="n">normed_embs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span><span class="o">.</span><span class="n">to_pos_scaling</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">embeddings</span><span class="p">]</span>

        <span class="c1"># Now calculate the variances of the embedding specifiers</span>
        <span class="n">var_normal_vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">normal_vec</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">normed_embs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
        <span class="n">var_supp_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">support_factor</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">normed_embs</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">))</span>
        <span class="n">var_scale_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">normed_embs</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">var_normal_vec</span><span class="p">,</span> <span class="n">var_supp_factor</span><span class="p">,</span> <span class="n">var_scale_factor</span></div>

<div class="viewcode-block" id="ConceptEmbedding.std_deviation"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.std_deviation">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">std_deviation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">],</span>
                      <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the (by default unbiased) standard deviation of a list of embs.</span>
<span class="sd">        The standard deviations are calculated on the unique normalized</span>
<span class="sd">        representations of the embeddings, and encompass standard deviation of:</span>

<span class="sd">        - the normal vector</span>
<span class="sd">        - the support vector factor (= distance to 0)</span>
<span class="sd">        - the scaling factor (= length of the normal vector).</span>

<span class="sd">        The deviations are calculated as the square root of the variances</span>
<span class="sd">        (see :py:meth:`variance`).</span>

<span class="sd">        :param embeddings: sequence of embeddings</span>
<span class="sd">        :param ddof: delta degrees of freedom: the divisor used in calculations</span>
<span class="sd">            is :math:`\text{num_embeddings} - \text{ddof}`;</span>
<span class="sd">            if ``ddof=1`` (default), the unbiased standard  deviation is</span>
<span class="sd">            obtained</span>
<span class="sd">        :returns: Tuple of standard deviation of</span>
<span class="sd">            ``(normal vecs, support factors, scaling factors)`` for</span>
<span class="sd">            normalized representations of given embeddings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var_normal_vec</span><span class="p">,</span> <span class="n">var_supp_factor</span><span class="p">,</span> <span class="n">var_scale_factor</span> <span class="o">=</span> \
            <span class="bp">cls</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">embeddings</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_normal_vec</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_supp_factor</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_scale_factor</span><span class="p">))</span></div>

<div class="viewcode-block" id="ConceptEmbedding.mean_by_angle"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.mean_by_angle">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">mean_by_angle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get embedding where distance to the given hyperplanes at each</span>
<span class="sd">        point sums up to 0.</span>

<span class="sd">        **The Math Behind**</span>

<span class="sd">        This routine approximates an &quot;average&quot; hyperplane from the given</span>
<span class="sd">        embeddings where here average hyperplane means the one for which the</span>
<span class="sd">        following holds:</span>
<span class="sd">        Given a point :math:`x` on the average hyperplane, the signed</span>
<span class="sd">        distances to all hyperplanes along the average hyperplane&#39;s normal</span>
<span class="sd">        vector sum up to zero.</span>
<span class="sd">        The signed distance from :math:`x` to a hyperplane H non-orthogonal</span>
<span class="sd">        to the average hyperplane is</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left(\left( (R\cdot n + x) \cap H \right) - x \right) \circ n,</span>

<span class="sd">        where</span>

<span class="sd">         - :math:`n` is the normalized normal vector of the average hyperplane,</span>
<span class="sd">         - :math:`(R \cdot n + x)` is the 1-dim affine sub-space through</span>
<span class="sd">           :math:`x` in the direction of :math:`n`, and</span>
<span class="sd">         - :math:`((R \cdot n + x) \cap H)` is the unique intersection of</span>
<span class="sd">           above line with :math:`H`.</span>

<span class="sd">        The average hyperplane has the following properties:</span>

<span class="sd">        - The average hyperplane is unique.</span>
<span class="sd">        - The average normal vector only depends on the normal vectors of the</span>
<span class="sd">          hyperplanes, not their supports/biases.</span>
<span class="sd">        - Given the normalized normal vector n of the average hyperplane,</span>
<span class="sd">          a support vector is given by:</span>

<span class="sd">          .. math::</span>
<span class="sd">            \frac{1}{N} \sum_{j=1}^{N} \frac{|b_j|^2}{n \circ b_j} \cdot n</span>

<span class="sd">          where the sum goes over the N hyperplanes, :math:`n` is a normalized</span>
<span class="sd">          normal vector of the average hyperplane and :math:`b_j` is the</span>
<span class="sd">          orthogonal support vector of the jth hyperplane</span>
<span class="sd">          (i.e. a support vector which is a multiple of the normal vector).</span>
<span class="sd">        - Assume normalized normal vectors of the hyperplanes which all lie in</span>
<span class="sd">          the same hypersphere and are given in angle coordinates of the</span>
<span class="sd">          1-hypersphere. An entry in the average normal vector in angle</span>
<span class="sd">          coordinates is the mean of the entries in the other hyperplane&#39;s</span>
<span class="sd">          normal vectors.</span>

<span class="sd">        **Implementation Notes**</span>

<span class="sd">        Normal vector:</span>
<span class="sd">          The normal vector is computationally expensive to calculate</span>
<span class="sd">          (should be the spherical barycenter of the normed normal vectors</span>
<span class="sd">          in one hemisphere)</span>
<span class="sd">          and can be approximated by the normalized barycenter of the</span>
<span class="sd">          normalized normal vectors which lie in the same hemisphere.</span>

<span class="sd">        Support:</span>
<span class="sd">          If the normal vectors do not differ too much, the support can also</span>
<span class="sd">          be approximated by the mean of the orthogonal support vectors</span>
<span class="sd">          (or be considered as an optimisation problem</span>
<span class="sd">          and be learned from the concept data).</span>

<span class="sd">        :returns: The embedding representing the average hyperplane of the</span>
<span class="sd">            hyperplanes represented by the given embeddings</span>
<span class="sd">        :raises: :py:exc:`ValueError` if the mean of the normalized normal</span>
<span class="sd">            vectors :math:`\frac{n_j}{|n_j|}` of the given embeddings is 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Value checks:</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_validate_embedding_list</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span>
        <span class="n">meta_info</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">meta_info</span>

        <span class="c1"># First norm all embeddings and bring them to the same hemisphere</span>
        <span class="n">normed_embeddings</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span><span class="o">.</span><span class="n">to_pos_scaling</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">embeddings</span><span class="p">]</span>
        <span class="n">normed_normal_vecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">normal_vec</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">normed_embeddings</span><span class="p">]</span>
        <span class="n">normed_support_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">support_factor</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">normed_embeddings</span><span class="p">]</span>
        <span class="n">normed_scaling_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">normed_embeddings</span><span class="p">]</span>

        <span class="c1"># Approximate normal vector: Take normalized mean of the concept vectors</span>
        <span class="n">mean_normal_vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">normed_normal_vecs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mean_normal_vec_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mean_normal_vec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">mean_normal_vec_length</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mean of normalized embedding normal vectors is &quot;</span>
                             <span class="s2">&quot;zero (all positive scaling); &quot;</span>
                             <span class="s2">&quot;cannot calculate mean embedding&quot;</span><span class="p">)</span>
        <span class="n">mean_normal_vec</span> <span class="o">/=</span> <span class="n">mean_normal_vec_length</span>
        <span class="n">mean_scaling_factor</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">normed_scaling_factors</span><span class="p">,</span>
                                                  <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Support bias:</span>
        <span class="c1"># 1/N \sum_{j=1}^{N} bias_j^2 / (mean_weight \circ (bias_j * weight_j))</span>
        <span class="n">cos_distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mean_normal_vec</span> <span class="o">*</span> <span class="p">(</span><span class="n">bias</span> <span class="o">*</span> <span class="n">weight</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">bias</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span>
                         <span class="nb">zip</span><span class="p">(</span><span class="n">normed_support_factors</span><span class="p">,</span> <span class="n">normed_normal_vecs</span><span class="p">)]</span>
        <span class="n">mean_support_factor</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">embeddings</span><span class="p">))</span> <span class="o">*</span>
                               <span class="c1"># supp / cos(supp to norm_weight)</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bias</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">cos_dist</span>
                                   <span class="k">if</span> <span class="n">cos_dist</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                                   <span class="c1"># no or orthogonal support</span>
                                   <span class="k">for</span> <span class="n">bias</span><span class="p">,</span> <span class="n">cos_dist</span> <span class="ow">in</span>
                                   <span class="nb">zip</span><span class="p">(</span><span class="n">normed_support_factors</span><span class="p">,</span> <span class="n">cos_distances</span><span class="p">)</span>
                               <span class="p">]))</span>

        <span class="n">mean_embedding</span><span class="p">:</span> <span class="n">ConceptEmbedding</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">normal_vec</span><span class="o">=</span><span class="n">mean_normal_vec</span><span class="p">,</span>
            <span class="n">support_factor</span><span class="o">=</span><span class="n">mean_support_factor</span><span class="p">,</span>
            <span class="n">scaling_factor</span><span class="o">=</span><span class="n">mean_scaling_factor</span><span class="p">,</span>
            <span class="o">**</span><span class="n">meta_info</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mean_embedding</span></div>

<div class="viewcode-block" id="ConceptEmbedding.__eq__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;ConceptEmbedding&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert both embeddings to unique representation and compare values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">norm_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span><span class="o">.</span><span class="n">to_pos_scaling</span><span class="p">()</span>
        <span class="n">norm_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span><span class="o">.</span><span class="n">to_pos_scaling</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">norm_other</span><span class="o">.</span><span class="n">scaling_factor</span><span class="p">,</span>
                            <span class="n">norm_self</span><span class="o">.</span><span class="n">scaling_factor</span><span class="p">))</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">norm_other</span><span class="o">.</span><span class="n">support_factor</span><span class="p">,</span>
                            <span class="n">norm_self</span><span class="o">.</span><span class="n">support_factor</span><span class="p">))</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">norm_other</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">,</span> <span class="n">norm_self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">))</span></div>

<div class="viewcode-block" id="ConceptEmbedding.__repr__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Information about concept, model, layer, concept vector and thresh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="s2">&quot;</span><span class="si">{cls_name}</span><span class="s2">(&quot;</span>
                 <span class="s2">&quot;concept=</span><span class="si">{concept_name}</span><span class="s2">, &quot;</span>
                 <span class="s2">&quot;layer_id=</span><span class="si">{layer_id}</span><span class="s2">, &quot;</span>
                 <span class="s2">&quot;normal_vec=</span><span class="si">{normal_vec}</span><span class="s2">, &quot;</span>
                 <span class="s2">&quot;support_factor=</span><span class="si">{support_factor}</span><span class="s2">, &quot;</span>
                 <span class="s2">&quot;scaling_factor=</span><span class="si">{scaling_factor}</span><span class="s2">, &quot;</span>
                 <span class="s2">&quot;model=</span><span class="si">{model}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cls_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">concept_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_name</span><span class="p">,</span>
                        <span class="n">layer_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer_id</span><span class="p">,</span>
                        <span class="n">normal_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_vec</span><span class="p">,</span>
                        <span class="n">support_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">support_factor</span><span class="p">,</span>
                        <span class="n">scaling_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span><span class="p">,</span>
                        <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">main_model</span><span class="p">))</span></div>

<div class="viewcode-block" id="ConceptEmbedding.__str__"><a class="viewcode-back" href="../../../apiref/generated/hybrid_learning.concepts.embeddings.ConceptEmbedding.html#hybrid_learning.concepts.embeddings.ConceptEmbedding.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Continental Automotive GmbH

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>